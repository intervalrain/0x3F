---
title: "LinkedList, Binary Tree, Tree 介紹"
order: 0
description: "鏈表與樹的基本概念、術語與結構類型"
tags: ["LinkedList", "Binary Tree", "Tree", "基礎概念"]
---

# LinkedList, Binary Tree, Tree 介紹

## 前言

**LinkedList（鏈表）** 和 **Tree（樹）** 是兩種最重要的非連續儲存結構，與陣列的連續儲存不同，它們通過指針連接節點。

---

## 鏈表基本概念

### 節點 (Node)

鏈表的基本單位，包含**資料**和**指針**。

```cpp
// 單向鏈表節點
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// 雙向鏈表節點
struct DoubleListNode {
    int val;
    DoubleListNode* prev;
    DoubleListNode* next;
    DoubleListNode(int x) : val(x), prev(nullptr), next(nullptr) {}
};
```

### 鏈表類型

#### 1. 單向鏈表 (Singly Linked List)

```
head → [1] → [2] → [3] → [4] → null
```

**特點**：
- 只能單向遍歷
- 節點只有 next 指針
- 空間效率高

#### 2. 雙向鏈表 (Doubly Linked List)

```
null ← [1] ⇄ [2] ⇄ [3] ⇄ [4] → null
```

**特點**：
- 可雙向遍歷
- 節點有 prev 和 next 指針
- 刪除操作更方便

#### 3. 循環鏈表 (Circular Linked List)

```
   ┌─────────────────┐
   ↓                 │
  [1] → [2] → [3] → [4]
```

**特點**：
- 最後一個節點指向第一個節點
- 無 null 結尾
- 可用於環形緩衝區

---

## 樹基本概念

### 樹的術語

```
        1 (root)
       / \
      2   3 (parent of 6,7)
     / \   \
    4   5   6 (child)
           / \
          7   8 (leaf)
```

#### 基本術語

- **節點 (Node)**：樹的基本單位
- **根節點 (Root)**：最頂端的節點（節點 1）
- **父節點 (Parent)**：有子節點的節點（節點 3 是 6 的父節點）
- **子節點 (Child)**：被父節點指向的節點（節點 6 是 3 的子節點）
- **葉節點 (Leaf)**：沒有子節點的節點（節點 4, 5, 7, 8）
- **兄弟節點 (Sibling)**：有相同父節點的節點（節點 2 和 3）
- **祖先 (Ancestor)**：從根到該節點路徑上的所有節點
- **後代 (Descendant)**：該節點的所有子樹節點

#### 樹的屬性

- **深度 (Depth)**：從根到該節點的邊數
  - 節點 1 深度 = 0
  - 節點 6 深度 = 2

- **高度 (Height)**：該節點到葉節點的最長路徑
  - 節點 6 高度 = 1
  - 樹的高度 = 根的高度 = 3

- **層級 (Level)**：深度 + 1
  - 節點 1 在第 1 層
  - 節點 6 在第 3 層

### 二元樹節點

```cpp
// 二元樹節點
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```

---

## 二元樹的類型

### 1. Full Binary Tree（滿二元樹）

**定義**：每個節點要麼有 0 個子節點，要麼有 2 個子節點。

```
        1
       / \
      2   3
     / \
    4   5
```

**特點**：
- 所有非葉節點都有兩個子節點
- 節點數 n = 2h + 1（h 為高度）

### 2. Perfect Binary Tree（完美二元樹）

**定義**：所有內部節點都有兩個子節點，且所有葉節點在同一層。

```
        1
       / \
      2   3
     / \ / \
    4  5 6  7
```

**特點**：
- 是滿二元樹的特例
- 節點數 n = 2^(h+1) - 1
- 最緊密的二元樹

### 3. Complete Binary Tree（完全二元樹）

**定義**：除了最後一層，所有層都是滿的，且最後一層的節點都靠左排列。

```
        1
       / \
      2   3
     / \ /
    4  5 6
```

**特點**：
- Heap 就是完全二元樹
- 可用陣列表示：
  - 父節點索引 i，左子節點 2i+1，右子節點 2i+2

**非完全二元樹範例**：
```
        1
       / \
      2   3
       \ / \
        5 6 7  (錯誤：節點 4 缺失)
```

### 4. Balanced Binary Tree（平衡二元樹）

**定義**：每個節點的左右子樹高度差不超過 1。

```
        1
       / \
      2   3
     /
    4
```

**特點**：
- AVL Tree、Red-Black Tree 都是平衡樹
- 保證 O(log n) 操作

**非平衡範例**：
```
    1
     \
      2
       \
        3  (高度差 > 1)
```

### 5. Binary Search Tree (BST)

**定義**：
- 左子樹所有節點 < 根節點
- 右子樹所有節點 > 根節點
- 左右子樹也是 BST

```
        5
       / \
      3   7
     / \ / \
    2  4 6  8
```

**特點**：
- 中序遍歷得到升序序列
- 查找、插入、刪除平均 O(log n)

---

## 一般樹 (General Tree)

### N-ary Tree（N 叉樹）

每個節點可以有任意數量的子節點。

```cpp
// N 叉樹節點
struct Node {
    int val;
    vector<Node*> children;
    Node(int x) : val(x) {}
};
```

```
        1
      / | \
     2  3  4
    /|  |
   5 6  7
```

---

## 特殊樹結構

### 1. Trie（字典樹/前綴樹）

用於字串查找。

```cpp
struct TrieNode {
    bool isEnd;
    TrieNode* children[26];
    TrieNode() : isEnd(false) {
        for (int i = 0; i < 26; i++) {
            children[i] = nullptr;
        }
    }
};
```

**應用**：
- 自動補全
- 拼寫檢查
- IP 路由

### 2. Segment Tree（線段樹）

用於區間查詢。

```
區間 [0, 7]
        [0,7]
       /     \
    [0,3]    [4,7]
    /   \    /   \
  [0,1] [2,3] [4,5] [6,7]
```

**應用**：
- 區間和查詢
- 區間最大/最小值
- 區間更新

### 3. Binary Indexed Tree / Fenwick Tree

用於高效計算前綴和。

**應用**：
- 動態前綴和
- 區間更新與查詢

---

## 樹的表示方法

### 1. 鏈表表示（常用）

```cpp
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
};
```

**優點**：
- 動態插入刪除
- 結構清晰

**缺點**：
- 指針開銷
- 無法隨機存取

### 2. 陣列表示（完全二元樹）

```cpp
vector<int> tree;
// 父節點 i
// 左子節點 2*i + 1
// 右子節點 2*i + 2
```

**優點**：
- 節省空間（無指針）
- 快速存取父子節點

**缺點**：
- 只適合完全二元樹
- 浪費空間（不完全時）

---

## 鏈表 vs 陣列

| 特性 | 陣列 | 鏈表 |
|-----|------|------|
| **儲存** | 連續 | 非連續 |
| **存取** | O(1) 隨機存取 | O(n) 順序存取 |
| **插入** | O(n) 需要移動 | O(1) 修改指針 |
| **刪除** | O(n) 需要移動 | O(1) 修改指針 |
| **空間** | 固定/需擴容 | 動態 |
| **Cache** | 友善 | 不友善 |

---

## 常見操作複雜度

### 鏈表

| 操作 | 單向鏈表 | 雙向鏈表 |
|-----|---------|---------|
| 頭部插入 | O(1) | O(1) |
| 尾部插入 | O(n) 或 O(1)（有尾指針） | O(1) |
| 刪除節點 | O(n) | O(1)（已知節點） |
| 查找 | O(n) | O(n) |

### 二元樹

| 操作 | 平衡 BST | 非平衡 BST |
|-----|---------|-----------|
| 查找 | O(log n) | O(n) |
| 插入 | O(log n) | O(n) |
| 刪除 | O(log n) | O(n) |
| 遍歷 | O(n) | O(n) |

---

## Dummy Node 技巧

在鏈表操作中，**Dummy Node（虛擬頭節點）** 可以簡化邊界處理。

```cpp
ListNode* dummy = new ListNode(0);
dummy->next = head;

// 操作...

ListNode* newHead = dummy->next;
delete dummy;
return newHead;
```

**優點**：
- 統一處理頭節點
- 避免空指針判斷
- 簡化插入刪除邏輯

---

## 經典問題分類

### 鏈表

1. **反轉問題**：反轉鏈表、反轉部分鏈表
2. **快慢指針**：環檢測、找中點、倒數第 k 個
3. **合併問題**：合併兩個鏈表、合併 k 個鏈表
4. **刪除問題**：刪除節點、刪除重複
5. **重排問題**：奇偶重排、分組反轉

### 二元樹

1. **遍歷問題**：前中後序、層序遍歷
2. **路徑問題**：路徑和、最長路徑
3. **構建問題**：從遍歷序列構建樹
4. **BST 問題**：驗證、查找、插入刪除
5. **LCA 問題**：最近公共祖先

---

## 重點回顧

### 鏈表

- **節點構成**：val + next（+ prev）
- **三種類型**：單向、雙向、循環
- **核心優勢**：動態插入刪除 O(1)
- **主要缺點**：無法隨機存取

### 樹

- **基本術語**：root, parent, child, leaf, sibling
- **二元樹類型**：
  - Full：每個節點 0 或 2 個子節點
  - Perfect：所有層都滿
  - Complete：除最後一層外都滿，最後一層靠左
  - Balanced：左右高度差 ≤ 1
  - BST：左 < 根 < 右

### 表示方法

- **鏈表表示**：動態、結構清晰
- **陣列表示**：完全二元樹、節省空間

### 下一步

接下來將學習鏈表和樹的具體操作與經典問題。
