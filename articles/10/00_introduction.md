---
title: 10-0. 動態規劃介紹
order: 0
description: 動態規劃的核心概念與基礎原理
tags:
  - 動態規劃
  - DP
  - 狀態轉移
  - 記憶化搜索
author: Rain Hu
date: '2025-10-08'
draft: false
---

# 動態規劃介紹

動態規劃（Dynamic Programming，簡稱 DP）是一種通過將複雜問題分解為更簡單的子問題來解決問題的算法設計技術。它是演算法設計中最重要且最常用的技巧之一。

## 什麼是動態規劃？

動態規劃的核心思想是：**避免重複計算，將中間結果保存起來，以空間換時間**。

> "Those who cannot remember the past are condemned to repeat it." — Dynamic Programming

## DP 的兩大特徵

動態規劃問題必須同時滿足以下兩個特徵：

### 1. 重疊子問題 (Overlapping Subproblems)

在解決問題的過程中，會**重複遇到相同的子問題**。

例如計算費波那契數列：
```
fib(5) = fib(4) + fib(3)
       = [fib(3) + fib(2)] + [fib(2) + fib(1)]
       = [[fib(2) + fib(1)] + fib(2)] + [fib(2) + fib(1)]
```

可以看到 `fib(2)` 被計算了 3 次，`fib(3)` 被計算了 2 次。這就是重疊子問題。

**遞迴樹示意圖：**
```
                    fib(5)
                   /      \
              fib(4)        fib(3)
             /     \        /     \
        fib(3)   fib(2)  fib(2)  fib(1)
        /   \     /  \    /  \
    fib(2) fib(1) 1  0   1   0
     / \
    1   0
```

### 2. 最優子結構 (Optimal Substructure)

問題的最優解可以由其**子問題的最優解**組合而成。

例如最短路徑問題：如果從 A 到 C 的最短路徑經過 B，那麼 A→B 和 B→C 也必須是最短路徑。

## DP vs 其他算法設計技巧

| 特性 | 動態規劃 (DP) | 分治法 (Divide and Conquer) | 貪心法 (Greedy) |
|------|--------------|---------------------------|----------------|
| 子問題性質 | 重疊子問題 | 獨立子問題 | 無需考慮子問題 |
| 最優子結構 | 需要 | 需要 | 需要 |
| 決策方式 | 考慮所有可能 | 分別解決後合併 | 每步選局部最優 |
| 求解方式 | 保存中間結果 | 遞迴求解 | 直接貪心選擇 |
| 時間複雜度 | 通常較低 | 可能較高（無記憶） | 通常最低 |
| 保證最優 | 是 | 是 | 不一定 |

**範例比較：**
- **DP**：背包問題（需要考慮所有可能的組合）
- **分治**：歸併排序（子問題獨立，不重疊）
- **貪心**：活動選擇問題（每次選最早結束的）

## DP 的核心要素

### 1. 狀態定義 (State Definition)

這是 DP 中**最關鍵也最困難**的一步。狀態定義決定了整個 DP 的解題思路。

**好的狀態定義應該：**
- 能夠表達問題的本質
- 包含足夠的資訊來做決策
- 不包含冗餘資訊
- 便於進行狀態轉移

**常見的狀態定義模式：**

| 模式 | 定義 | 適用問題 |
|------|------|----------|
| `dp[i]` | 到第 i 個位置的最優解 | 1D 序列問題 |
| `dp[i][j]` | 區間 [i, j] 的最優解 | 區間 DP |
| `dp[i][j]` | 前 i 個物品，容量 j 的最優解 | 背包問題 |
| `dp[i][j]` | 字符串 s[0..i] 和 t[0..j] 的最優解 | 序列匹配 |
| `dp[i][j][k]` | 第 i 天，進行了 j 次交易，狀態為 k | 狀態機 DP |
| `dp[mask]` | 集合狀態為 mask 的最優解 | 狀態壓縮 DP |

### 2. 轉移方程 (Transition Equation)

**這是 DP 的靈魂所在！** 轉移方程描述了如何從已知的子問題推導出當前問題的解。

**轉移方程的一般形式：**
```
dp[當前狀態] = function(dp[之前的狀態])
```

**常見的轉移方程模式：**

```cpp
// 1. 選或不選
dp[i] = max(dp[i-1], dp[i-1] + value[i])

// 2. 枚舉決策
dp[i] = max/min { dp[j] + cost(j, i) } for all valid j

// 3. 區間合併
dp[i][j] = min { dp[i][k] + dp[k+1][j] + cost } for k in [i, j)

// 4. 序列匹配
dp[i][j] = dp[i-1][j-1] + match(s[i], t[j])
         OR min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + cost
```

### 3. 初始化條件 (Base Cases)

確定邊界條件，通常是最小規模的子問題的解。

**範例：**
```cpp
// 爬樓梯：dp[i] 表示到第 i 階的方法數
dp[0] = 1;  // 站在地面，有 1 種方法（不動）
dp[1] = 1;  // 到第 1 階，有 1 種方法（走 1 步）

// 背包問題：dp[i][0] 表示容量為 0
for (int i = 0; i <= n; i++) {
    dp[i][0] = 0;  // 容量為 0，價值必為 0
}
```

### 4. 遍歷順序 (Iteration Order)

決定計算 DP 狀態的順序，確保在計算當前狀態時，所需的子問題已經被計算過。

**常見的遍歷順序：**

```cpp
// 1. 正序遍歷（1D DP）
for (int i = 1; i <= n; i++) {
    dp[i] = f(dp[i-1], dp[i-2], ...);
}

// 2. 逆序遍歷（0-1 背包空間優化）
for (int i = 0; i < n; i++) {
    for (int j = W; j >= w[i]; j--) {  // 逆序！
        dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
    }
}

// 3. 區間長度遞增（區間 DP）
for (int len = 2; len <= n; len++) {
    for (int i = 0; i + len - 1 < n; i++) {
        int j = i + len - 1;
        dp[i][j] = f(dp[i][k], dp[k+1][j], ...);
    }
}

// 4. 兩層循環（2D DP）
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        dp[i][j] = f(dp[i-1][j], dp[i][j-1], ...);
    }
}
```

## DP 的兩種實現方式

### 1. Top-down (自頂向下) - Memoization (記憶化搜索)

從原問題出發，遞迴地分解為子問題，並將計算結果保存起來。

**優點：**
- 思路直觀，容易理解
- 只計算需要的子問題（Lazy Evaluation）
- 代碼結構清晰

**缺點：**
- 遞迴調用有額外開銷
- 可能遇到堆疊溢出（Stack Overflow）
- 不易進行空間優化

**範例：費波那契數列**
```cpp
class Solution {
private:
    vector<int> memo;

    int fib_helper(int n) {
        // Base cases
        if (n <= 1) return n;

        // 如果已經計算過，直接返回
        if (memo[n] != -1) return memo[n];

        // 計算並保存結果
        memo[n] = fib_helper(n - 1) + fib_helper(n - 2);
        return memo[n];
    }

public:
    int fib(int n) {
        memo.assign(n + 1, -1);  // 初始化為 -1 表示未計算
        return fib_helper(n);
    }
};
```

### 2. Bottom-up (自底向上) - Tabulation (遞推)

從最小的子問題開始，逐步計算更大的子問題，直到原問題。

**優點：**
- 無遞迴開銷
- 易於進行空間優化
- 更容易分析時間複雜度

**缺點：**
- 可能計算不需要的子問題
- 初學者較難理解
- 遍歷順序需要仔細設計

**範例：費波那契數列**
```cpp
class Solution {
public:
    int fib(int n) {
        if (n <= 1) return n;

        vector<int> dp(n + 1);
        dp[0] = 0;
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
    }
};
```

**空間優化版本：**
```cpp
class Solution {
public:
    int fib(int n) {
        if (n <= 1) return n;

        int prev2 = 0, prev1 = 1;

        for (int i = 2; i <= n; i++) {
            int curr = prev1 + prev2;
            prev2 = prev1;
            prev1 = curr;
        }

        return prev1;
    }
};
```

## 空間優化技巧

### 1. 滾動數組 (Rolling Array)

當 DP 轉移只依賴於前面少數幾個狀態時，可以用滾動數組優化空間。

**範例：只依賴前一層**
```cpp
// 原本：dp[i][j] = f(dp[i-1][...])
// 優化：dp[j] = f(dp[...])

// 優化前：O(n*m) 空間
vector<vector<int>> dp(n + 1, vector<int>(m + 1));
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        dp[i][j] = dp[i-1][j] + dp[i][j-1];
    }
}

// 優化後：O(m) 空間
vector<int> dp(m + 1);
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        dp[j] = dp[j] + dp[j-1];  // dp[j] 原本是上一層的值
    }
}
```

### 2. 狀態壓縮

當狀態可以用位元表示時，可以大幅節省空間。

```cpp
// 集合大小為 n，用 2^n 個位元表示所有子集
int dp[1 << n];
```

## 如何識別 DP 問題？

### 1. 問題類型特徵

| 問題特徵 | DP 可能性 | 範例 |
|----------|-----------|------|
| 求最大值/最小值 | 高 | 最長遞增子序列、最小編輯距離 |
| 計數問題 | 高 | 有多少種方法、組合數 |
| 判斷可行性 | 中 | 能否分割成兩個相等子集 |
| 有明確的子問題結構 | 高 | 爬樓梯、背包問題 |
| 涉及選擇/決策 | 高 | 打家劫舍、股票買賣 |

### 2. 關鍵字識別

當題目出現以下關鍵字時，很可能是 DP 問題：
- 最大/最小/最長/最短
- 多少種方法/方案數
- 是否可能/可行
- 最優解
- 前 i 個元素
- 子序列/子數組
- 分割/劃分

### 3. DP 問題的思考流程

```
1. 問題能否分解為子問題？
   └─> 是 → 繼續
   └─> 否 → 可能不是 DP

2. 子問題之間有重疊嗎？
   └─> 是 → 繼續
   └─> 否 → 考慮分治或遞迴

3. 問題有最優子結構嗎？
   └─> 是 → 繼續
   └─> 否 → 考慮貪心或其他方法

4. 如何定義狀態？
   └─> dp[i] 表示什麼？
   └─> 需要幾維狀態？

5. 如何進行狀態轉移？
   └─> 當前狀態如何從之前的狀態推導？
   └─> 轉移方程是什麼？

6. 初始條件是什麼？
   └─> 最小規模的子問題的解是什麼？

7. 遍歷順序如何安排？
   └─> 確保計算當前狀態時，依賴的狀態已計算
```

## DP 的常見陷阱與技巧

### 常見陷阱

1. **狀態定義不清晰**
   - 狀態包含的資訊不足或過多
   - 狀態無法唯一確定子問題

2. **遍歷順序錯誤**
   - 0-1 背包空間優化時未逆序遍歷
   - 區間 DP 未按長度遞增順序

3. **初始化錯誤**
   - 忘記初始化邊界條件
   - 初始化值不符合題意（如求最小值時初始化為 0）

4. **空間優化時覆蓋了需要的值**
   - 未考慮空間優化後的狀態依賴

### 實用技巧

1. **從記憶化搜索開始**
   - 先寫出遞迴解法
   - 加上記憶化
   - 再改寫為遞推形式

2. **畫出狀態轉移圖**
   - 用表格模擬 DP 過程
   - 觀察狀態之間的依賴關係

3. **先解決小規模問題**
   - 手動計算前幾個狀態
   - 尋找規律

4. **檢查轉移方程的完備性**
   - 是否考慮了所有情況？
   - 是否有遺漏的決策？

## 複雜度分析

### 時間複雜度

通常是：**狀態數 × 每個狀態的轉移時間**

```
狀態數：所有可能的狀態組合數
轉移時間：計算一個狀態需要的時間

範例：
- 1D DP: O(n) 狀態，O(1) 轉移 → O(n)
- 2D DP: O(n*m) 狀態，O(1) 轉移 → O(n*m)
- 區間 DP: O(n²) 狀態，O(n) 轉移 → O(n³)
- 狀態壓縮: O(2^n * m) 狀態，O(1) 轉移 → O(2^n * m)
```

### 空間複雜度

- 未優化：等於狀態數
- 滾動數組優化：通常可以降一維
- 最優情況：O(1)（如費波那契）

## 小結

動態規劃是演算法設計中的強大工具，掌握 DP 的關鍵在於：

1. **理解問題的本質**：識別重疊子問題和最優子結構
2. **精準定義狀態**：狀態定義決定了整個解題思路
3. **推導轉移方程**：這是 DP 的靈魂所在
4. **正確初始化和遍歷**：確保計算順序正確
5. **持續練習**：通過大量練習培養 DP 思維

接下來的章節中，我們將深入學習各種經典的 DP 問題類型，包括：
- 1 維 DP
- 區間 DP
- 背包 DP（0-1 背包、完全背包）
- 序列 DP（LIS、LCS、編輯距離）
- 網格 DP
- 狀態壓縮 DP
- Tree DP
- 狀態機 DP
- DP 優化技巧

讓我們開始 DP 的學習之旅吧！
