---
title: "貪心法介紹"
order: 0
description: "貪心法的核心思想、可行性條件與證明方法"
tags: ["greedy", "algorithm-design"]
---

# 0. 貪心法介紹

## 什麼是貪心法？

**貪心法 (Greedy Algorithm)** 是一種算法設計策略，其核心思想是：**在每一步決策中，都選擇當前看起來最優的選擇，從而希望導致全局最優解。**

與動態規劃需要考慮所有可能的決策路徑不同，貪心法只關注「當下最好的選擇」，具有以下特點：

- **局部最優決策**：每一步都做出在當前狀態下最好的選擇
- **不回溯**：一旦做出選擇就不再改變
- **無後效性**：當前的選擇不依賴於未來的選擇

### 簡單例子：找零錢問題

假設我們有面額為 {1, 5, 10, 25} 的硬幣，要找零 41 元，如何用最少的硬幣？

**貪心策略**：每次選擇不超過剩餘金額的最大面額硬幣。

```
41 = 25 + 16
   = 25 + 10 + 6
   = 25 + 10 + 5 + 1
共需要 4 枚硬幣
```

## 貪心法 vs 動態規劃

| 特性 | 貪心法 | 動態規劃 |
|------|--------|----------|
| 決策方式 | 局部最優 | 考慮所有可能 |
| 是否回溯 | 不回溯 | 需要保存子問題解 |
| 時間複雜度 | 通常較低 | 通常較高 |
| 適用場景 | 具有貪心選擇性質 | 具有最優子結構 |
| 正確性 | 需要證明 | 遞推式保證正確 |

### 重要區別

```
動態規劃：f(n) = min(f(n-1), f(n-2), ...) + cost
          需要考慮多種選擇，選最優

貪心法：  choice = greedy_select(current_state)
          只考慮一種選擇（當前最優）
```

### 反例：貪心法不總是正確

考慮面額為 {1, 3, 4} 的找零問題，找零 6 元：

```
貪心法：6 = 4 + 1 + 1  (3 枚硬幣) ✗
最優解：6 = 3 + 3      (2 枚硬幣) ✓
```

這說明貪心法的正確性需要嚴格證明！

## 貪心法的可行性要件

要使用貪心法解決問題，必須滿足以下兩個條件：

### 1. 貪心選擇性質 (Greedy Choice Property)

**定義**：問題的全局最優解可以通過一系列局部最優選擇得到。

**關鍵**：我們可以先做出在當前看來最優的選擇，然後解決剩下的子問題。

### 2. 最優子結構 (Optimal Substructure)

**定義**：問題的最優解包含其子問題的最優解。

**關鍵**：做出貪心選擇後，原問題簡化為一個相似的子問題。

### 兩者的關係

```
貪心選擇性質：保證局部最優 → 全局最優
最優子結構：  保證子問題也能用相同策略求解

兩者結合 → 貪心法可行
```

## 如何證明貪心法的正確性

### 方法一：反證法 (Proof by Contradiction)

**步驟**：
1. 假設存在比貪心解更優的解
2. 分析這個更優解與貪心解的差異
3. 證明可以將更優解轉換為貪心解而不變差
4. 得出矛盾，證明貪心解就是最優解

**範例**：區間調度問題

```
問題：選擇最多不重疊的區間
貪心策略：按結束時間排序，每次選最早結束的

證明：
假設存在最優解 OPT ≠ Greedy
設 Greedy 第一個選擇 g₁，OPT 第一個選擇 o₁
因為 g₁ 結束時間最早，所以 end(g₁) ≤ end(o₁)

將 OPT 中的 o₁ 替換為 g₁：
- 因為 end(g₁) ≤ end(o₁)，所以不會產生新的衝突
- 替換後仍是最優解
- 重複此過程，OPT 可以轉換為 Greedy
- 因此 Greedy 就是最優解
```

### 方法二：交換論證 (Exchange Argument)

**步驟**：
1. 考慮任意最優解
2. 證明可以通過一系列「交換」操作將其轉換為貪心解
3. 證明每次交換不會使解變差
4. 因此貪心解也是最優解

**範例**：Huffman 編碼

```
問題：構造最優二叉樹使得帶權路徑長度最小
貪心策略：每次合併頻率最小的兩個節點

證明：
設最優樹 T*，設頻率最小的兩個字符為 a, b
如果 a, b 不是最深層的兄弟節點，可以交換：
- 將 a, b 與最深層的兩個兄弟節點交換位置
- 交換後總代價不會增加（因為 a, b 頻率最小）
- 因此貪心選擇（合併 a, b）不會更差
```

### 方法三：數學歸納法 (Mathematical Induction)

**步驟**：
1. 證明 base case（n=1 或 n=2）時貪心法正確
2. 假設 n=k 時貪心法正確
3. 證明 n=k+1 時貪心法仍正確
4. 得出對所有 n，貪心法都正確

**範例**：跳躍遊戲

```
問題：每個位置表示最大跳躍長度，判斷能否到達終點
貪心策略：維護能到達的最遠位置

證明：
Base case: n=1 時，已在終點，正確
歸納假設：對於長度為 k 的數組，貪心法正確
歸納步驟：對於長度為 k+1 的數組
  如果貪心法說能到達第 k 個位置，
  且 k + nums[k] ≥ k+1，則必能到達第 k+1 個位置
  這是因為前 k 個位置的可達性已由歸納假設保證
```

## 常見貪心策略

### 1. 排序後貪心

**核心思想**：先對輸入進行排序，然後按某種順序進行貪心選擇。

```cpp
// 典型模板
sort(items.begin(), items.end(), comparator);
for (auto& item : items) {
    if (can_choose(item)) {
        choose(item);
    }
}
```

**適用問題**：
- 區間調度
- 分發餅乾
- 分配任務

### 2. 優先隊列貪心

**核心思想**：使用優先隊列動態維護「當前最優」的選擇。

```cpp
// 典型模板
priority_queue<Item, vector<Item>, Comparator> pq;
while (!pq.empty()) {
    auto best = pq.top();
    pq.pop();
    process(best);
    // 可能加入新的候選項
}
```

**適用問題**：
- Huffman 編碼
- 任務調度
- 會議室分配

### 3. 區間貪心

**核心思想**：處理區間相關問題，通常按起始或結束時間排序。

```cpp
// 典型模板
sort(intervals.begin(), intervals.end(),
     [](auto& a, auto& b) { return a.end < b.end; });

int last_end = INT_MIN;
for (auto& interval : intervals) {
    if (interval.start >= last_end) {
        // 選擇這個區間
        last_end = interval.end;
    }
}
```

**適用問題**：
- 不重疊區間
- 射箭戳氣球
- 視頻拼接

### 4. 狀態壓縮貪心

**核心思想**：維護一個或多個變量表示當前狀態，每次更新這些變量。

```cpp
// 典型模板
int state = initial_state;
for (auto& item : items) {
    state = greedy_update(state, item);
}
```

**適用問題**：
- 跳躍遊戲
- 加油站
- 股票買賣

## 如何識別貪心問題

### 關鍵信號

1. **問題要求「最多」、「最少」、「最大」、「最小」**
   - 最多不重疊區間
   - 最少跳躍次數
   - 最大利潤

2. **具有明確的「局部最優」標準**
   - 選擇最早結束的
   - 選擇最大的
   - 選擇最接近的

3. **做出選擇後，問題規模縮小**
   - 選擇一個區間後，剩餘的仍是區間選擇問題
   - 跳一步後，剩餘的仍是跳躍問題

4. **無需「回溯」或「嘗試多種可能」**
   - 如果需要嘗試多種選擇並比較，通常是 DP 而非貪心
   - 如果選擇之間有依賴關係，可能不適合貪心

### 識別流程

```
Step 1: 問題是否要求最優解？
        ↓ 是
Step 2: 是否能找到明確的「局部最優」策略？
        ↓ 是
Step 3: 能否證明局部最優 → 全局最優？
        ↓ 是
Step 4: 使用貪心法

反例：如果無法證明，考慮：
- 動態規劃（需要考慮多種選擇）
- 回溯法（需要嘗試所有可能）
```

## 貪心法的常見陷阱

### 陷阱 1：忽略正確性證明

```cpp
// 錯誤示範：背包問題用貪心
// 問題：0-1 背包，每個物品只能選一次
// 錯誤貪心：按價值密度排序後貪心選擇

sort(items.begin(), items.end(),
     [](auto& a, auto& b) {
         return a.value/a.weight > b.value/b.weight;
     });
// 這對 0-1 背包是錯誤的！

反例：
容量 = 10
物品1：weight=6, value=30  (密度=5)
物品2：weight=5, value=20  (密度=4)
物品3：weight=5, value=20  (密度=4)

貪心選物品1：總價值 = 30
最優解選物品2+3：總價值 = 40
```

### 陷阱 2：排序標準錯誤

```cpp
// 問題：區間調度
// 錯誤策略：按起始時間排序

// 反例：
// 區間1：[1, 100]
// 區間2：[2, 3]
// 區間3：[4, 5]
//
// 按起始時間選擇區間1，只能選1個
// 但最優是選擇區間2和3，可以選2個

// 正確策略：按結束時間排序
```

### 陷阱 3：忽略邊界條件

```cpp
// 問題：跳躍遊戲
// 忽略了「當前位置不可達」的情況

for (int i = 0; i < n; i++) {
    maxReach = max(maxReach, i + nums[i]);
}
// 缺少檢查：if (i > maxReach) return false;
```

### 陷阱 4：過早優化

```cpp
// 先確保正確性，再考慮優化
// 不要在沒有證明正確性之前就優化代碼

// 第一步：寫出清晰的貪心策略
// 第二步：證明正確性
// 第三步：實現並測試
// 第四步：必要時優化
```

## 貪心 vs DP：何時使用哪個？

| 問題特徵 | 使用貪心 | 使用 DP |
|----------|----------|---------|
| 局部選擇影響全局 | ✗ | ✓ |
| 需要回溯 | ✗ | ✓ |
| 多種選擇需要比較 | ✗ | ✓ |
| 有明確的貪心策略 | ✓ | ✗ |
| 能證明貪心正確性 | ✓ | ✗ |

### 經典例子對比

```
1. 找零錢問題：
   - 特殊面額（如 {1,5,10,25}）：貪心 ✓
   - 任意面額：DP ✓

2. 背包問題：
   - 分數背包（可分割）：貪心 ✓
   - 0-1 背包：DP ✓

3. 最短路徑：
   - 無負權邊：貪心（Dijkstra）✓
   - 有負權邊：DP（Bellman-Ford）✓
```

## 學習路徑建議

### 初級：理解基本概念

1. 區間調度問題（理解貪心選擇性質）
2. 分發餅乾（理解排序貪心）
3. 跳躍遊戲（理解狀態維護）

### 中級：掌握常見模式

1. 區間問題（合併、覆蓋、分組）
2. 序列貪心（排序、狀態壓縮）
3. 優先隊列貪心（Huffman、任務調度）

### 高級：複雜證明與優化

1. 證明貪心策略的正確性
2. 設計反例驗證貪心策略
3. 組合使用貪心與其他技巧

## 總結

貪心法是一種強大但需要謹慎使用的算法設計策略：

**優點**：
- 實現簡單
- 時間複雜度通常較低
- 代碼清晰易懂

**缺點**：
- 不是所有問題都適用
- 需要嚴格證明正確性
- 容易出錯（選擇錯誤的貪心策略）

**關鍵要點**：
1. **驗證可行性**：確保問題具有貪心選擇性質和最優子結構
2. **證明正確性**：使用反證法、交換論證或數學歸納法
3. **測試反例**：嘗試構造反例來驗證貪心策略
4. **清晰實現**：先確保正確性，再考慮優化

在接下來的章節中，我們將深入探討各種貪心問題的經典模式和解決方案。
