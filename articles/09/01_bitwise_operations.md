---
title: 09-1. Bitwise Operations
order: 1
description: 基本位元運算子與常用技巧
tags:
  - bit manipulation
  - bitwise operators
  - 基礎
author: Rain Hu
date: ''
draft: true
---

# 1. Bitwise Operations (基本位元運算)

位元運算子是直接對二進制位元進行操作的運算子，是所有位元操作的基礎。

## 基本運算子

### 1. AND 運算子 (`&`)

**規則：**兩個位元都是 1 時，結果才是 1。

```
真值表：
  0 & 0 = 0
  0 & 1 = 0
  1 & 0 = 0
  1 & 1 = 1
```

**範例：**

```cpp
int a = 0b1010;  // 10
int b = 0b1100;  // 12

int c = a & b;   // 0b1000 = 8

// 詳細過程：
  1010  (a = 10)
& 1100  (b = 12)
──────
  1000  (c = 8)
```

**常見用途：**
- 提取特定位元
- 清除特定位元
- 檢查位元是否為 1

```cpp
// 檢查第 i 位元是否為 1
bool is_set = (x & (1 << i)) != 0;

// 保留低 n 位元
int lower_bits = x & ((1 << n) - 1);

// 檢查是否為偶數（最低位為 0）
bool is_even = (x & 1) == 0;
```

### 2. OR 運算子 (`|`)

**規則：**兩個位元中有一個是 1 時，結果就是 1。

```
真值表：
  0 | 0 = 0
  0 | 1 = 1
  1 | 0 = 1
  1 | 1 = 1
```

**範例：**

```cpp
int a = 0b1010;  // 10
int b = 0b1100;  // 12

int c = a | b;   // 0b1110 = 14

// 詳細過程：
  1010  (a = 10)
| 1100  (b = 12)
──────
  1110  (c = 14)
```

**常見用途：**
- 設定特定位元為 1
- 合併多個位元遮罩

```cpp
// 設定第 i 位元為 1
x |= (1 << i);

// 合併多個 flags
int flags = FLAG_A | FLAG_B | FLAG_C;

// 設定低 n 位元為 1
x |= ((1 << n) - 1);
```

### 3. XOR 運算子 (`^`)

**規則：**兩個位元不同時，結果為 1；相同時，結果為 0。

```
真值表：
  0 ^ 0 = 0
  0 ^ 1 = 1
  1 ^ 0 = 1
  1 ^ 1 = 0
```

**範例：**

```cpp
int a = 0b1010;  // 10
int b = 0b1100;  // 12

int c = a ^ b;   // 0b0110 = 6

// 詳細過程：
  1010  (a = 10)
^ 1100  (b = 12)
──────
  0110  (c = 6)
```

**重要性質：**

```cpp
// 1. 自反性：x ^ x = 0
int x = 10;
int result = x ^ x;  // 0

// 2. 恆等性：x ^ 0 = x
int result2 = x ^ 0;  // 10

// 3. 交換律：a ^ b = b ^ a
// 4. 結合律：(a ^ b) ^ c = a ^ (b ^ c)

// 5. 應用：交換兩個變數（不需要額外空間）
a ^= b;
b ^= a;
a ^= b;
// 現在 a 和 b 已交換
```

**常見用途：**
- 切換特定位元
- 找出唯一出現的數字
- 檢測位元差異

```cpp
// 切換第 i 位元
x ^= (1 << i);

// 切換所有位元
x ^= ~0;

// 找出兩個數字不同的位元
int diff = a ^ b;
```

### 4. NOT 運算子 (`~`)

**規則：**位元取反（0 變 1，1 變 0）。

```
真值表：
  ~0 = 1
  ~1 = 0
```

**範例：**

```cpp
int a = 0b00001010;  // 10 (假設 8 位元)

int b = ~a;  // 0b11110101 = -11 (二補數表示)

// 詳細過程：
  00001010  (a = 10)
  ↓ NOT
  11110101  (b = -11，因為 MSB = 1)
```

**注意事項：**

在有符號整數中，`~x` 的結果是 `-x - 1`：

```cpp
int x = 5;
int y = ~x;  // -6

// 證明：
// x =  00000101 (5)
// ~x = 11111010 (這是 -6 的二補數表示)
```

**常見用途：**
- 建立遮罩來清除位元
- 找到二補數

```cpp
// 清除第 i 位元
x &= ~(1 << i);

// 計算 -x
int neg_x = ~x + 1;
```

### 5. 左移運算子 (`<<`)

**規則：**將所有位元向左移動 n 位，右邊補 0。

```
範例：
  00001010  (10)
  << 2
  ↓
  00101000  (40)
```

**數學意義：**左移 n 位等於乘以 2^n

```cpp
int x = 5;

int y1 = x << 1;  // 10  (5 * 2^1 = 5 * 2 = 10)
int y2 = x << 2;  // 20  (5 * 2^2 = 5 * 4 = 20)
int y3 = x << 3;  // 40  (5 * 2^3 = 5 * 8 = 40)

// 詳細過程（8 位元）：
  00000101  (5)
  << 1
  00001010  (10)

  00000101  (5)
  << 2
  00010100  (20)
```

**常見用途：**
- 快速乘以 2 的冪次
- 建立位元遮罩
- 計算 2 的冪次

```cpp
// 計算 2^n
int power_of_2 = 1 << n;

// 建立第 i 位元的 mask
int mask = 1 << i;

// 快速乘法
int times_8 = x << 3;  // x * 8
```

### 6. 右移運算子 (`>>`)

**規則：**將所有位元向右移動 n 位。

```
範例：
  00101000  (40)
  >> 2
  ↓
  00001010  (10)
```

**數學意義：**右移 n 位等於除以 2^n（向下取整）

```cpp
int x = 20;

int y1 = x >> 1;  // 10  (20 / 2 = 10)
int y2 = x >> 2;  // 5   (20 / 4 = 5)
int y3 = x >> 3;  // 2   (20 / 8 = 2.5 → 2)

// 詳細過程（8 位元）：
  00010100  (20)
  >> 1
  00001010  (10)

  00010100  (20)
  >> 2
  00000101  (5)
```

**兩種右移：**

1. **邏輯右移（Logical Shift）**：左邊補 0
2. **算術右移（Arithmetic Shift）**：左邊補符號位

```cpp
// 無符號整數：邏輯右移
unsigned int a = 0b10000000;
unsigned int b = a >> 2;  // 0b00100000

// 有符號整數：算術右移（保持符號）
int c = -8;  // 0b11111000 (8 位元的 -8)
int d = c >> 1;  // 0b11111100 (仍然是負數 -4)
```

**常見用途：**
- 快速除以 2 的冪次
- 提取高位元

```cpp
// 快速除法
int half = x >> 1;     // x / 2
int quarter = x >> 2;  // x / 4

// 提取高 n 位元
int high_bits = x >> (total_bits - n);
```

## 運算子優先級

位元運算子的優先級**較低**，需要注意括號的使用：

```cpp
// 錯誤：優先級問題
if (x & 1 == 0)  // 錯誤！等同於 x & (1 == 0)

// 正確：使用括號
if ((x & 1) == 0)  // 正確

// 優先級順序（由高到低）：
// ~  (NOT)
// <<, >>  (位移)
// &  (AND)
// ^  (XOR)
// |  (OR)
```

## 常用技巧

以下是一些常用的位元運算技巧：

### 1. `x ^ 1` - 翻轉最低位

```cpp
int x = 0b1010;  // 10
int y = x ^ 1;   // 0b1011 = 11

int z = 0b1011;  // 11
int w = z ^ 1;   // 0b1010 = 10

// 用途：在 0 和 1 之間切換
int toggle_01 = x ^ 1;

// 在二進制樹中切換左右子節點
int left_child = index * 2;
int right_child = (index * 2) ^ 1;  // 或 index * 2 + 1
```

### 2. `x ^ ~x` - 全為 1

```cpp
int x = 0b10101010;
int y = x ^ ~x;  // 0b11111111 = -1

// 原理：
  10101010  (x)
^ 01010101  (~x)
──────────
  11111111  (全為 1)
```

### 3. `x & (x - 1)` - 移除最低位的 1

```cpp
int x = 0b10110;  // 22
int y = x & (x - 1);  // 0b10100 = 20

// 詳細過程：
  x     = 10110
  x - 1 = 10101
  ──────────────
  x & (x-1) = 10100  (最低位的 1 被移除)

// 用途：計算 1 的個數（Brian Kernighan 演算法）
int count_ones(int x) {
    int count = 0;
    while (x) {
        x &= x - 1;  // 每次移除一個 1
        count++;
    }
    return count;
}
```

### 4. `x & -x` - 保留最低位的 1

```cpp
int x = 0b10110;  // 22
int y = x & -x;   // 0b00010 = 2

// 原理：-x 是 x 的二補數
  x  =  00010110  (22)
  -x =  11101010  (-22，二補數)
  ───────────────
  x & -x = 00000010  (只保留最低位的 1)

// 用途：Fenwick Tree (Binary Indexed Tree)
int lowbit(int x) {
    return x & -x;
}
```

### 5. `x | (x + 1)` - 填充最低位的 0

```cpp
int x = 0b10110;  // 22
int y = x | (x + 1);  // 0b10111 = 23

// 詳細過程：
  x     = 10110
  x + 1 = 10111
  ──────────────
  x | (x+1) = 10111  (最低位的 0 被填充為 1)
```

## 複雜度分析

所有基本位元運算的時間複雜度都是 **O(1)**，因為它們都是單一的 CPU 指令。

- **時間複雜度：** O(1)
- **空間複雜度：** O(1)

## LeetCode 題目

### 題目 1: 461. Hamming Distance

**題目連結：** https://leetcode.com/problems/hamming-distance/

**題目描述：**

兩個整數之間的漢明距離是指其二進制表示中不同位元的數量。給定兩個整數 `x` 和 `y`，計算它們之間的漢明距離。

**範例：**

```
輸入: x = 1, y = 4
輸出: 2

解釋:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
漢明距離為 2
```

**解法：**

```cpp
class Solution {
public:
    int hammingDistance(int x, int y) {
        // 方法 1: XOR + 計算 1 的個數
        int xor_result = x ^ y;  // 不同的位元會是 1
        return __builtin_popcount(xor_result);

        // 方法 2: 手動計算（Brian Kernighan 演算法）
        // int xor_result = x ^ y;
        // int count = 0;
        // while (xor_result) {
        //     xor_result &= xor_result - 1;
        //     count++;
        // }
        // return count;
    }
};
```

**解析：**

```
Step 1: XOR 找出不同的位元
  0001  (x = 1)
^ 0100  (y = 4)
──────
  0101  (xor_result = 5)

Step 2: 計算 1 的個數
  0101 有 2 個 1，所以漢明距離為 2
```

**時間複雜度：** O(1) - 固定 32 位元
**空間複雜度：** O(1)

### 題目 2: 477. Total Hamming Distance

**題目連結：** https://leetcode.com/problems/total-hamming-distance/

**題目描述：**

給定一個整數陣列 `nums`，計算陣列中所有數字對之間的漢明距離總和。

**範例：**

```
輸入: nums = [4, 14, 2]
輸出: 6

解釋:
4:  0100
14: 1110
2:  0010

hamming(4, 14) = 2
hamming(4, 2) = 2
hamming(14, 2) = 2
總和 = 2 + 2 + 2 = 6
```

**解法：**

```cpp
class Solution {
public:
    int totalHammingDistance(vector<int>& nums) {
        int n = nums.size();
        int total = 0;

        // 對於每個位元位置
        for (int i = 0; i < 32; i++) {
            int count_ones = 0;

            // 計算這個位置有多少個 1
            for (int num : nums) {
                count_ones += (num >> i) & 1;
            }

            // 有 count_ones 個 1 和 (n - count_ones) 個 0
            // 它們之間的配對數量就是貢獻
            total += count_ones * (n - count_ones);
        }

        return total;
    }
};
```

**解析：**

對於每個位元位置，如果有 `k` 個數字在該位置是 1，有 `n-k` 個數字是 0，則該位置對總漢明距離的貢獻是 `k * (n-k)`。

```
範例: [4, 14, 2]
位置 0: 0, 0, 0 → 貢獻 = 0 * 3 = 0
位置 1: 0, 1, 1 → 貢獻 = 2 * 1 = 2
位置 2: 1, 1, 0 → 貢獻 = 2 * 1 = 2
位置 3: 0, 1, 0 → 貢獻 = 1 * 2 = 2
總和 = 0 + 2 + 2 + 2 = 6
```

**時間複雜度：** O(32n) = O(n)
**空間複雜度：** O(1)

### 題目 3: 136. Single Number

**題目連結：** https://leetcode.com/problems/single-number/

**題目描述：**

給定一個非空整數陣列，除了某個元素只出現一次以外，其餘每個元素均出現兩次。找出那個只出現一次的元素。

**範例：**

```
輸入: [2, 2, 1]
輸出: 1

輸入: [4, 1, 2, 1, 2]
輸出: 4
```

**解法：**

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int result = 0;
        for (int num : nums) {
            result ^= num;
        }
        return result;
    }
};
```

**解析：**

利用 XOR 的性質：
- `a ^ a = 0`
- `a ^ 0 = a`
- XOR 滿足交換律和結合律

```
範例: [4, 1, 2, 1, 2]
  4 ^ 1 ^ 2 ^ 1 ^ 2
= 4 ^ (1 ^ 1) ^ (2 ^ 2)  // 交換律和結合律
= 4 ^ 0 ^ 0
= 4
```

**時間複雜度：** O(n)
**空間複雜度：** O(1)

### 題目 4: 137. Single Number II

**題目連結：** https://leetcode.com/problems/single-number-ii/

**題目描述：**

給定一個整數陣列，除了某個元素只出現一次以外，其餘每個元素均出現三次。找出那個只出現一次的元素。

**範例：**

```
輸入: [2, 2, 3, 2]
輸出: 3

輸入: [0, 1, 0, 1, 0, 1, 99]
輸出: 99
```

**解法：**

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ones = 0, twos = 0;

        for (int num : nums) {
            // twos 記錄出現兩次的位元
            twos |= ones & num;

            // ones 記錄出現一次的位元
            ones ^= num;

            // 清除出現三次的位元
            int threes = ones & twos;
            ones &= ~threes;
            twos &= ~threes;
        }

        return ones;
    }

    // 方法 2: 統計每個位元
    int singleNumber_v2(vector<int>& nums) {
        int result = 0;

        // 對於每個位元位置
        for (int i = 0; i < 32; i++) {
            int count = 0;

            // 計算這個位置有多少個 1
            for (int num : nums) {
                count += (num >> i) & 1;
            }

            // 如果 count % 3 != 0，說明單獨的數字在這個位置是 1
            if (count % 3 != 0) {
                result |= (1 << i);
            }
        }

        return result;
    }
};
```

**解析：**

**方法 1（位元狀態機）：**
- `ones`: 記錄出現 1 次的位元
- `twos`: 記錄出現 2 次的位元
- 當某位元出現 3 次時，將其從 `ones` 和 `twos` 中清除

**方法 2（統計法）：**
- 對於每個位元位置，統計所有數字在該位置的 1 的個數
- 如果個數不能被 3 整除，說明單獨的數字在該位置是 1

```
範例: [2, 2, 3, 2]
2: 010
2: 010
3: 011
2: 010

位置 0: 0+0+1+0 = 1 (1%3=1) → result 第 0 位 = 1
位置 1: 1+1+1+1 = 4 (4%3=1) → result 第 1 位 = 1
位置 2: 0+0+0+0 = 0 (0%3=0) → result 第 2 位 = 0

result = 011 = 3
```

**時間複雜度：** O(n)
**空間複雜度：** O(1)

## 常見陷阱

### 1. 運算子優先級

```cpp
// 錯誤
if (x & 1 == 0)  // 等同於 x & (1 == 0)

// 正確
if ((x & 1) == 0)
```

### 2. 有符號數的右移

```cpp
int x = -8;
int y = x >> 1;  // 算術右移，y = -4（不是 2147483644）

// 如果需要邏輯右移，使用無符號數
unsigned int ux = -8;
unsigned int uy = ux >> 1;  // 邏輯右移
```

### 3. 左移溢位

```cpp
int x = 1 << 31;  // 可能導致未定義行為（有符號整數溢位）

// 使用無符號數或明確轉型
unsigned int y = 1U << 31;  // 正確
```

### 4. 負數的位元表示

```cpp
int x = -1;
// x 在二進制中是全 1 (0xFFFFFFFF)
// 不是 0x80000001

cout << bitset<32>(x) << endl;  // 11111111111111111111111111111111
```

## 小結

基本位元運算是所有進階技巧的基礎，掌握這些運算子能夠：
1. 高效地操作二進制資料
2. 解決特定類型的演算法問題（如找唯一數字）
3. 優化程式效能
4. 理解底層資料結構（如 Fenwick Tree）

在下一章節中，我們將學習進階的位元運算技巧，包括位元遮罩和子集枚舉。
