---
title: 09-0. 位元運算介紹
order: 0
description: 位元運算的基礎概念與術語
tags:
  - bit manipulation
  - binary
  - 基礎
author: Rain Hu
date: '2025-10-08'
draft: false
---

# 0. 位元運算介紹

位元運算 (Bit Manipulation) 是直接在二進制位元層級上進行的運算，是電腦科學中最基礎且高效的運算方式之一。

## Byte 介紹

在電腦中，資料的最小單位是 **bit**（位元），而 **byte**（位元組）是由 8 個 bits 組成：

```
1 byte = 8 bits

例如：
  bit:  7  6  5  4  3  2  1  0  (位元索引)
       ┌──┬──┬──┬──┬──┬──┬──┬──┐
byte:  │ 1│ 0│ 1│ 0│ 1│ 1│ 0│ 0│ = 172 (十進制)
       └──┴──┴──┴──┴──┴──┴──┴──┘
```

常見的資料型態大小：
- `char`: 1 byte (8 bits)
- `short`: 2 bytes (16 bits)
- `int`: 4 bytes (32 bits)
- `long long`: 8 bytes (64 bits)

## C++ 中的位元表示

### 1. 二進制字面值（Binary Literal）

使用 `0b` 或 `0B` 前綴來表示二進制數字（C++14 起）：

```cpp
int a = 0b1010;      // 二進制 1010 = 十進制 10
int b = 0b11111111;  // 二進制 11111111 = 十進制 255
int c = 0b1'0000'0000; // 可使用 ' 分隔，方便閱讀
```

### 2. 十六進制字面值（Hexadecimal Literal）

使用 `0x` 或 `0X` 前綴來表示十六進制數字：

```cpp
int a = 0x0A;   // 十六進制 0A = 十進制 10
int b = 0xFF;   // 十六進制 FF = 十進制 255
int c = 0x1A2B; // 十六進制 1A2B = 十進制 6699
```

**轉換對照表：**

```
二進制     十六進制   十進制
0000        0          0
0001        1          1
0010        2          2
0011        3          3
0100        4          4
0101        5          5
0110        6          6
0111        7          7
1000        8          8
1001        9          9
1010        A          10
1011        B          11
1100        C          12
1101        D          13
1110        E          14
1111        F          15
```

### 3. bitset 容器

C++ STL 提供的 `bitset` 容器可以方便地處理位元：

```cpp
#include <bitset>

// 宣告一個 8 位元的 bitset，初始值為 0
bitset<8> bits;

// 從整數初始化
bitset<8> bits1(42);  // 00101010

// 從字串初始化
bitset<8> bits2("10101100");

// 輸出
cout << bits1 << endl;  // 輸出：00101010
cout << bits1.to_ulong() << endl;  // 輸出：42
```

## 位元基本概念

### 最低位 (LSB - Least Significant Bit)

最低位是二進制數字中**最右邊**的位元，對數值的影響最小（代表 2^0 = 1）。

```
  二進制: 1 0 1 0 1 1 0 0
                      ↑
                     LSB (第 0 位)
```

### 最高位 (MSB - Most Significant Bit)

最高位是二進制數字中**最左邊**的位元，對數值的影響最大。在有符號整數中，MSB 也被稱為**符號位**。

```
  二進制: 1 0 1 0 1 1 0 0
          ↑
         MSB (第 7 位，在 8-bit 數字中)
```

**有符號整數的 MSB：**
- MSB = 0：正數
- MSB = 1：負數（使用二補數表示）

## 什麼是補數 (Complement)

### 一補數（One's Complement，反碼）

一補數是將所有位元取反（0 變 1，1 變 0）：

```
原數:    0 0 1 0 1 1 0 0  (44)
       ┌──────────────────
一補數:  1 1 0 1 0 0 1 1  (~44)
```

在 C++ 中使用 `~` 運算子：

```cpp
int x = 44;        // 0b00101100
int y = ~x;        // 0b11010011
```

### 二補數（Two's Complement）

二補數是 C++ 中用來表示負數的標準方式，計算方法為：**一補數 + 1**

```
原數:    0 0 1 0 1 1 0 0  (44)
一補數:  1 1 0 1 0 0 1 1
      +                1
       ───────────────────
二補數:  1 1 0 1 0 1 0 0  (-44)
```

**二補數的優點：**
1. 加法和減法使用相同的電路
2. 只有一個零（沒有 +0 和 -0 的區別）
3. 運算規則簡單

**範例：**

```cpp
int x = 44;        // 0b00101100
int y = -x;        // 0b11010100 (二補數)

// 驗證：44 + (-44) = 0
  00101100  (44)
+ 11010100  (-44)
──────────
 100000000  (溢位被捨棄，結果為 0)
```

### 為什麼 `-x = ~x + 1`？

這是二補數的定義：

```cpp
int x = 10;
int neg_x = ~x + 1;  // -10

// 驗證
cout << neg_x << endl;  // 輸出：-10
```

**證明：**

```
x + (-x) = 0
x + (~x + 1) = 0
x + ~x = -1  (所有位元都是 1)
因此 ~x + 1 = -x
```

## 什麼是楔子（Mask，位元遮罩）

位元遮罩（Bitmask）是一個特定的位元模式，用來**篩選、設定或修改**特定的位元。

### 常見的 Mask 操作

```cpp
int x = 0b10101100;  // 原始數字

// 1. 保留特定位元（使用 AND）
int mask1 = 0b00001111;  // 只保留低 4 位元
int result1 = x & mask1;  // 0b00001100

// 2. 設定特定位元（使用 OR）
int mask2 = 0b00010000;  // 設定第 4 位元
int result2 = x | mask2;  // 0b10111100

// 3. 清除特定位元（使用 AND NOT）
int mask3 = 0b11110111;  // 清除第 3 位元
int result3 = x & mask3;  // 0b10100100

// 4. 切換特定位元（使用 XOR）
int mask4 = 0b00001000;  // 切換第 3 位元
int result4 = x ^ mask4;  // 0b10100100
```

### 動態建立 Mask

```cpp
// 建立第 i 位元為 1 的 mask
int mask = 1 << i;

// 範例：
int mask_bit3 = 1 << 3;  // 0b00001000
int mask_bit5 = 1 << 5;  // 0b00100000

// 建立低 n 位元全為 1 的 mask
int mask_low_n = (1 << n) - 1;

// 範例：
int mask_low_4 = (1 << 4) - 1;  // 0b00001111
int mask_low_8 = (1 << 8) - 1;  // 0b11111111
```

## 為什麼位元運算快？

位元運算直接在 **CPU 硬體層級**執行，具有以下優勢：

### 1. 單週期執行

大多數位元運算只需要 **1 個 CPU 時鐘週期**：

```cpp
// 這些運算都非常快
x & y;   // AND 運算
x | y;   // OR 運算
x ^ y;   // XOR 運算
~x;      // NOT 運算
x << n;  // 左移（等同於乘以 2^n）
x >> n;  // 右移（等同於除以 2^n）
```

### 2. 替代算術運算

```cpp
// 乘以 2 的冪次
int double_x = x << 1;   // 比 x * 2 快
int quad_x = x << 2;     // 比 x * 4 快
int times_8 = x << 3;    // 比 x * 8 快

// 除以 2 的冪次
int half_x = x >> 1;     // 比 x / 2 快
int quarter = x >> 2;    // 比 x / 4 快

// 取模運算（當除數是 2 的冪次時）
int mod_4 = x & 3;       // 比 x % 4 快 (3 = 0b11)
int mod_8 = x & 7;       // 比 x % 8 快 (7 = 0b111)
int mod_16 = x & 15;     // 比 x % 16 快 (15 = 0b1111)
```

### 3. 記憶體效率

使用位元可以大幅節省記憶體：

```cpp
// 使用 bool 陣列
bool visited[1000];  // 1000 bytes

// 使用 bitset
bitset<1000> visited;  // 125 bytes (1000 / 8)

// 節省了 87.5% 的記憶體！
```

### 4. 並行處理

一次運算可以處理多個位元：

```cpp
// 使用位元表示 8 個開關狀態
int switches = 0b10101010;  // 4 個開關開啟，4 個關閉

// 一次運算檢查所有開關
if (switches & 0b10000000) {  // 檢查第 7 個開關
    // ...
}
```

## 效能比較

以下是一些實際的效能比較（僅供參考）：

```cpp
// 乘法 vs 左移
x * 2;     // ~3-5 個時鐘週期
x << 1;    // ~1 個時鐘週期

// 除法 vs 右移
x / 2;     // ~10-40 個時鐘週期
x >> 1;    // ~1 個時鐘週期

// 取模 vs AND
x % 8;     // ~10-40 個時鐘週期
x & 7;     // ~1 個時鐘週期
```

## 注意事項

雖然位元運算很快，但也有一些需要注意的地方：

### 1. 可讀性

位元運算可能降低程式碼可讀性：

```cpp
// 較難理解
if (flags & 0x80) { ... }

// 較容易理解
const int FLAG_ACTIVE = 0x80;
if (flags & FLAG_ACTIVE) { ... }
```

### 2. 編譯器優化

現代編譯器已經能夠自動優化簡單的運算：

```cpp
// 編譯器可能會自動優化成位移
int result = x * 4;  // 編譯器優化成 x << 2
```

### 3. 適用場景

位元運算最適合：
- 底層系統程式設計
- 嵌入式系統
- 演算法競賽
- 效能關鍵路徑
- 狀態壓縮（State Compression）

## 小結

位元運算是一個強大的工具，掌握它能夠：
1. 提高程式執行效率
2. 節省記憶體空間
3. 解決特定類型的問題（如狀態壓縮、集合操作）
4. 理解電腦底層運作原理

在接下來的章節中，我們將深入學習各種位元運算技巧及其應用。
