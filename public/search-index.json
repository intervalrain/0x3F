{
  "articles": [
    {
      "id": "01-00_introduction",
      "title": "01-0. 演算法與資料結構心法",
      "description": "學習演算法與資料結構的基本概念與心法",
      "tags": [
        "基礎",
        "入門"
      ],
      "folder": "01",
      "slug": "00_introduction",
      "path": "/articles/01/00_introduction",
      "excerpt": "演算法與資料結構心法 什麼是演算法？ 演算法是解決問題的步驟和方法。一個好的演算法應該具備以下特性： - 正確性：能夠正確解決問題 - 效率性：時間和空間複雜度合理 - 可讀性：代碼清晰易懂 - 可維護性：容易修改和擴展 學習心法 1. 理解問題本質：在開始寫代碼前，先確保完全理解問題 2. 從簡單開始：先解決簡單的情況，再擴展到複雜場景 3. 多畫圖：視覺化能幫助理解演算法的運作 4. 刻意練習",
      "order": 0,
      "draft": false
    },
    {
      "id": "01-01_complexity",
      "title": "01-1. 複雜度分析",
      "description": "時間複雜度與空間複雜度的基本概念，以及如何根據 Constraints 分析最佳演算法",
      "tags": [
        "複雜度",
        "Big O",
        "效能分析"
      ],
      "folder": "01",
      "slug": "01_complexity",
      "path": "/articles/01/01_complexity",
      "excerpt": "複雜度 (Complexity) 時間複雜度 (Time Complexity) 時間複雜度用來衡量演算法執行所需的時間，通常使用大 O 記號 (Big O Notation) 來表示。 !complexity 常見的時間複雜度 - O(1) - 常數時間：不論輸入大小，執行時間固定 - O(log n) - 對數時間：如二分搜尋 - O(n) - 線性時間：需要遍歷所有元素一次 - O(n lo",
      "order": 1,
      "draft": false
    },
    {
      "id": "01-02_data_structures",
      "title": "01-2. 基本資料結構",
      "description": "Array 與 Linked List 的特性、CRUD 操作，以及資料結構的選擇策略",
      "tags": [
        "資料結構",
        "Array",
        "Linked List",
        "Tree"
      ],
      "folder": "01",
      "slug": "02_data_structures",
      "path": "/articles/01/02_data_structures",
      "excerpt": "基本資料結構 (Basic Data Structures) 前言 對於任何資料結構，我們最關心的是它的 CRUD 操作： - Create (建立) - Read (讀取) - Update (更新) - Delete (刪除) 所有複雜的資料結構，都是以 Array 或 Linked List 為基礎延伸而來。 --- Array (陣列) 概念 陣列是一種連續記憶體空間儲存相同類型元素的資料",
      "order": 2,
      "draft": false
    },
    {
      "id": "01-03_dynamic_array",
      "title": "01-3. 動態陣列",
      "description": "動態陣列的擴縮容機制、索引邊界檢查，以及如何實作動態陣列",
      "tags": [
        "動態陣列",
        "Vector",
        "擴容",
        "Amortized"
      ],
      "folder": "01",
      "slug": "03_dynamic_array",
      "path": "/articles/01/03_dynamic_array",
      "excerpt": "動態陣列 (Dynamic Array) 前言 靜態陣列的大小在編譯時就已經確定，無法動態調整。而動態陣列（如 C++ 的 `vector`）可以在執行時動態擴展或縮減容量。 --- 動態擴容 (Dynamic Expansion) 為什麼需要擴容？ 當元素數量超過陣列容量時，需要： 1. 分配一塊更大的連續記憶體空間 2. 將舊資料複製到新空間 3. 釋放舊記憶體 擴容策略 不同語言/實作有不同",
      "order": 3,
      "draft": false
    },
    {
      "id": "01-04_hashmap",
      "title": "01-4. HashMap 原理",
      "description": "HashMap 的 O(1) 查找原理、哈希衝突解決、負載因子與擴容機制",
      "tags": [
        "HashMap",
        "Hash Table",
        "哈希衝突",
        "負載因子",
        "Amortized"
      ],
      "folder": "01",
      "slug": "04_hashmap",
      "path": "/articles/01/04_hashmap",
      "excerpt": "HashMap 原理 前言 HashMap (哈希表) 是最常用的資料結構之一，能在 O(1) 時間內完成查找、插入、刪除操作。 核心問題：為什麼 HashMap 的查找是 O(1)？ --- HashMap 的原理 基本概念 HashMap 的核心思想： 1. 使用哈希函數將 key 轉換為陣列索引 2. 直接透過索引存取資料（O(1)） 為什麼是 O(1)？ 因為 HashMap 底層是陣列，",
      "order": 4,
      "draft": false
    },
    {
      "id": "01-05_linked_list_operations",
      "title": "01-5. Linked List 操作與變體",
      "description": "Linked List 的插入、刪除操作，以及 Doubly Linked List 和 Deque 的介紹",
      "tags": [
        "Linked List",
        "Doubly Linked List",
        "Deque",
        "插入",
        "刪除"
      ],
      "folder": "01",
      "slug": "05_linked_list_operations",
      "path": "/articles/01/05_linked_list_operations",
      "excerpt": "Linked List 操作與變體 前言 Linked List 是最基本的動態資料結構之一。理解其操作細節，對於解決 LeetCode 題目至關重要。 --- Singly Linked List 基本操作 1. 插入操作 (Insertion) 在頭部插入 (Insert at Head) 時間複雜度: O(1) 步驟: 在尾部插入 (Insert at Tail) 時間複雜度: O(n) -",
      "order": 5,
      "draft": false
    },
    {
      "id": "01-06_stack_and_queue",
      "title": "01-6. Stack 與 Queue",
      "description": "Stack (LIFO) 與 Queue (FIFO) 的原理、實作與應用",
      "tags": [
        "Stack",
        "Queue",
        "LIFO",
        "FIFO"
      ],
      "folder": "01",
      "slug": "06_stack_and_queue",
      "path": "/articles/01/06_stack_and_queue",
      "excerpt": "Stack 與 Queue 前言 Stack 和 Queue 是兩種最基本的線性資料結構，它們的差別在於元素的存取順序。 --- Stack (堆疊) 基本概念 Stack 遵循 LIFO (Last In, First Out) 原則：後進先出。 基本操作 時間複雜度 | 操作 | 時間複雜度 | |-----|----------| | push | O(1) | | pop | O(1) |",
      "order": 6,
      "draft": false
    },
    {
      "id": "01-07_heap",
      "title": "01-7. Heap 與 Priority Queue",
      "description": "Heap 的原理、實作與應用，以及 Priority Queue 的使用",
      "tags": [
        "Heap",
        "Priority Queue",
        "Binary Heap",
        "堆積"
      ],
      "folder": "01",
      "slug": "07_heap",
      "path": "/articles/01/07_heap",
      "excerpt": "Heap 與 Priority Queue 前言 Heap (堆積) 是一種特殊的完全二元樹，常用於實作 Priority Queue (優先隊列)。 --- Heap 的概念 定義 Heap 是一棵完全二元樹，滿足以下性質： - Max Heap (大根堆)：每個節點的值 ≥ 其子節點的值 - Min Heap (小根堆)：每個節點的值 ≤ 其子節點的值 完全二元樹 完全二元樹：除了最後一層外，",
      "order": 7,
      "draft": false
    },
    {
      "id": "01-08_tree",
      "title": "01-8. Tree (樹)",
      "description": "Binary Tree、BST、TreeNode 結構，以及各種樹的變體",
      "tags": [
        "Tree",
        "Binary Tree",
        "BST",
        "AVL",
        "Red-Black Tree"
      ],
      "folder": "01",
      "slug": "08_tree",
      "path": "/articles/01/08_tree",
      "excerpt": "Tree (樹) 前言 Tree (樹) 是一種非線性的資料結構，由節點 (Node) 和邊 (Edge) 組成，廣泛應用於檔案系統、資料庫索引、編譯器等。 --- 基本概念 術語 --- Binary Tree (二元樹) 定義 每個節點最多有兩個子節點的樹。 類型 1. Full Binary Tree (滿二元樹) 每個節點都有 0 或 2 個子節點。 2. Complete Binary ",
      "order": 8,
      "draft": false
    },
    {
      "id": "01-09_graph",
      "title": "01-9. Graph (圖)",
      "description": "圖的表示方法、有向圖、無向圖、有權圖，以及基本演算法",
      "tags": [
        "Graph",
        "DFS",
        "BFS",
        "有向圖",
        "無向圖",
        "鄰接矩陣",
        "鄰接串列"
      ],
      "folder": "01",
      "slug": "09_graph",
      "path": "/articles/01/09_graph",
      "excerpt": "Graph (圖) 前言 Graph (圖) 是一種由節點 (Vertex) 和邊 (Edge) 組成的資料結構，用於表示複雜的關係網路。 --- 基本概念 術語 --- 圖的分類 1. 有向圖 (Directed Graph) 邊有方向性。 應用: 任務依賴、網頁連結、社交媒體追蹤 2. 無向圖 (Undirected Graph) 邊無方向性。 應用: 社交網路好友關係、道路網路 3. 有權圖",
      "order": 9,
      "draft": false
    },
    {
      "id": "01-10_stl_containers",
      "title": "01-10. C++ STL 容器",
      "description": "C++ STL 常用容器介紹：set, map, unordered_map, unordered_set 等",
      "tags": [
        "STL",
        "set",
        "map",
        "unordered_map",
        "multiset",
        "C++"
      ],
      "folder": "01",
      "slug": "10_stl_containers",
      "path": "/articles/01/10_stl_containers",
      "excerpt": "C++ STL 容器 前言 STL (Standard Template Library) 提供了豐富的容器和演算法，是 C++ 程式設計的重要工具。 --- 序列容器 (Sequence Containers) vector 動態陣列。 | 操作 | 時間複雜度 | |-----|----------| | push_back | 攤銷 O(1) | | pop_back | O(1) | | ",
      "order": 10,
      "draft": false
    },
    {
      "id": "01-11_advanced_structures",
      "title": "01-11. 進階資料結構",
      "description": "LeetCode 中常用的進階資料結構：Trie、Segment Tree、Fenwick Tree、Monotonic Stack 等",
      "tags": [
        "Trie",
        "Segment Tree",
        "Fenwick Tree",
        "Monotonic Stack",
        "Disjoint Set"
      ],
      "folder": "01",
      "slug": "11_advanced_structures",
      "path": "/articles/01/11_advanced_structures",
      "excerpt": "進階資料結構 前言 除了 STL 提供的基本容器外，LeetCode 中還會用到一些特殊的資料結構。本章介紹這些進階結構的原理與應用。 --- Trie (字典樹) 概念 Trie 是一種樹狀結構，用於高效儲存和查詢字串集合。 實作 時間複雜度 | 操作 | 時間複雜度 | |-----|----------| | insert | O(m) - m 為字串長度 | | search | O(m)",
      "order": 11,
      "draft": false
    },
    {
      "id": "02-00_algorithm_overview",
      "title": "02-0. 演算法概述",
      "description": "演算法的選擇策略：以找某值為例，探討時間與空間的權衡",
      "tags": [
        "演算法",
        "複雜度",
        "Hash Table",
        "Binary Search"
      ],
      "folder": "02",
      "slug": "00_algorithm_overview",
      "path": "/articles/02/00_algorithm_overview",
      "excerpt": "演算法概述 前言 選擇合適的演算法，取決於資料特性和使用場景。本章以「找某值」為例，說明不同情況下的最佳策略。 --- 問題：在陣列中查找某個值 場景 1: 亂序陣列，單次查詢 資料: `[3, 7, 1, 9, 2, 5]` 需求: 查找 `target = 9` 是否存在 解法：線性遍歷 (Linear Search) 時間複雜度: O(n) 空間複雜度: O(1) 結論: 亂序陣列必須遍歷，",
      "order": 0,
      "draft": false
    },
    {
      "id": "02-01_sorting",
      "title": "02-1. 排序演算法",
      "description": "常見排序演算法：穩定性、原地排序，以及各種排序方法的比較",
      "tags": [
        "排序",
        "Sorting",
        "Bubble Sort",
        "Quick Sort",
        "Merge Sort"
      ],
      "folder": "02",
      "slug": "01_sorting",
      "path": "/articles/02/01_sorting",
      "excerpt": "排序演算法 前言 排序是最基本且重要的演算法之一。了解各種排序演算法的特性，有助於在不同場景選擇最合適的方法。 --- 排序的基本概念 穩定性 (Stability) 定義: 相同值的元素，排序後保持原有的相對順序。 為什麼重要？ 原地排序 (In-place) 定義: 只使用 O(1) 額外空間的排序。 --- 簡單排序 (O(n²)) 1. Bubble Sort (冒泡排序) 原理: 重複比",
      "order": 1,
      "draft": false
    },
    {
      "id": "02-02_brute_force",
      "title": "02-2. Brute Force (暴力法)",
      "description": "暴力法的概念、應用場景與優化策略",
      "tags": [
        "Brute Force",
        "暴力法",
        "窮舉"
      ],
      "folder": "02",
      "slug": "02_brute_force",
      "path": "/articles/02/02_brute_force",
      "excerpt": "Brute Force (暴力法) 前言 Brute Force (暴力法) 是最直接的解題策略：嘗試所有可能的解法，直到找到答案。 --- 基本概念 定義 暴力法透過窮舉所有可能性來解決問題。 ###特性 - ✓ 一定能找到答案（如果存在） - ✓ 容易理解和實作 - ✗ 時間複雜度高 - ✗ 不適合大資料 --- 經典範例 1. Two Sum (暴力解) 時間複雜度: O(n²) 空間複雜度",
      "order": 2,
      "draft": false
    },
    {
      "id": "02-03_divide_and_conquer",
      "title": "02-3. Divide and Conquer (分治法)",
      "description": "分治法的核心思想：分割、解決、合併",
      "tags": [
        "Divide and Conquer",
        "分治法",
        "遞迴"
      ],
      "folder": "02",
      "slug": "03_divide_and_conquer",
      "path": "/articles/02/03_divide_and_conquer",
      "excerpt": "Divide and Conquer (分治法) 前言 Divide and Conquer (分治法) 是一種重要的演算法設計策略，將大問題分割成小問題，分別解決後再合併結果。 --- 核心思想 三步驟 1. Divide (分割): 將問題分成若干子問題 2. Conquer (解決): 遞迴解決子問題 3. Combine (合併): 將子問題的解合併成原問題的解 遞迴結構 --- 經典範例",
      "order": 3,
      "draft": false
    },
    {
      "id": "02-04_dynamic_programming",
      "title": "02-4. Dynamic Programming (動態規劃)",
      "description": "動態規劃的核心思想：記憶化、狀態轉移方程",
      "tags": [
        "Dynamic Programming",
        "DP",
        "動態規劃",
        "記憶化"
      ],
      "folder": "02",
      "slug": "04_dynamic_programming",
      "path": "/articles/02/04_dynamic_programming",
      "excerpt": "Dynamic Programming (動態規劃) 前言 Dynamic Programming (DP) 是一種透過將問題分解成子問題，並儲存子問題的解來避免重複計算的演算法策略。 --- 核心思想 兩個關鍵特性 1. 重疊子問題 (Overlapping Subproblems)    - 子問題會被重複計算 2. 最優子結構 (Optimal Substructure)    - 最優解包",
      "order": 4,
      "draft": false
    },
    {
      "id": "02-05_greedy",
      "title": "02-5. Greedy (貪心法)",
      "description": "貪心法的核心思想：局部最優解導向全域最優解",
      "tags": [
        "Greedy",
        "貪心法",
        "局部最優"
      ],
      "folder": "02",
      "slug": "05_greedy",
      "path": "/articles/02/05_greedy",
      "excerpt": "Greedy (貪心法) 前言 Greedy (貪心法) 是一種在每一步都選擇當前最優解的演算法策略，期望透過局部最優達到全域最優。 --- 核心思想 定義 每一步都做出當下看起來最好的選擇，不回頭修改。 貪心 vs DP | 特性 | 貪心法 | DP | |-----|-------|---| | 決策 | 局部最優 | 考慮所有子問題 | | 回溯 | 不回溯 | 可能需要 | | 正確性 ",
      "order": 5,
      "draft": false
    },
    {
      "id": "02-06_backtracking",
      "title": "02-6. Backtracking (回溯法)",
      "description": "回溯法：窮舉所有可能解，遇到不可行就回退",
      "tags": [
        "Backtracking",
        "回溯法",
        "DFS",
        "剪枝"
      ],
      "folder": "02",
      "slug": "06_backtracking",
      "path": "/articles/02/06_backtracking",
      "excerpt": "Backtracking (回溯法) 前言 Backtracking (回溯法) 是一種透過嘗試所有可能性，在發現當前路徑不可行時回退的演算法策略。 --- 核心思想 定義 回溯法 = DFS + 剪枝 + 回退 模板 --- 經典問題 1. 全排列 (Permutations) 問題: 生成所有排列 決策樹: --- 2. 組合 (Combinations) 問題: 從 n 個數中選 k 個 剪",
      "order": 6,
      "draft": false
    },
    {
      "id": "02-07_branch_and_bound",
      "title": "02-7. Branch and Bound (分支定界法)",
      "description": "分支定界法：透過界限函數剪枝，找到最優解",
      "tags": [
        "Branch and Bound",
        "分支定界",
        "最優化"
      ],
      "folder": "02",
      "slug": "07_branch_and_bound",
      "path": "/articles/02/07_branch_and_bound",
      "excerpt": "Branch and Bound (分支定界法) 前言 Branch and Bound (分支定界法) 是一種用於求解最優化問題的演算法，透過界限函數來剪枝，避免搜尋無用的分支。 --- 核心思想 定義 分支定界 = 回溯法 + 界限函數 + 最優解追蹤 vs 回溯法 | 特性 | 回溯法 | 分支定界 | |-----|-------|---------| | 目標 | 找所有解 | 找最優解",
      "order": 7,
      "draft": false
    },
    {
      "id": "03-00_introduction",
      "title": "03-0. 滑動視窗與雙指針介紹",
      "description": "滑動視窗與雙指針的核心概念、使用場景與解題模板",
      "tags": [
        "Sliding Window",
        "Two Pointers",
        "滑動視窗",
        "雙指針"
      ],
      "folder": "03",
      "slug": "00_introduction",
      "path": "/articles/03/00_introduction",
      "excerpt": "滑動視窗與雙指針 前言 滑動視窗 (Sliding Window) 和 雙指針 (Two Pointers) 是處理陣列/字串問題最常用的技巧，能將 O(n²) 的暴力解優化到 O(n)。 --- 核心概念 滑動視窗 定義: 在陣列上維護一個「窗口」，透過移動窗口的左右邊界來尋找答案。 特點: - 窗口在陣列上「滑動」 - 只需遍歷一次 O(n) - 適合連續子陣列問題 雙指針 定義: 使用兩個指",
      "order": 0,
      "draft": false
    },
    {
      "id": "03-01_fixed_length_window",
      "title": "03-1. 定長滑動視窗",
      "description": "固定窗口大小的滑動視窗技巧與經典題目",
      "tags": [
        "Sliding Window",
        "Fixed Length",
        "定長視窗"
      ],
      "folder": "03",
      "slug": "01_fixed_length_window",
      "path": "/articles/03/01_fixed_length_window",
      "excerpt": "定長滑動視窗 (Fixed-Length Sliding Window) 核心概念 定長滑動視窗指的是窗口大小固定為 k 的滑動視窗問題。 特點 - 窗口大小固定不變 - 每次移動：右邊加入新元素，左邊移除舊元素 - 時間複雜度：O(n) - 適合求「每個大小為 k 的子陣列的某個屬性」 --- 通用模板 模板說明 1. 建立窗口：先建立大小為 k 的初始窗口 `[0, k-1]` 2. 更新答案",
      "order": 1,
      "draft": false
    },
    {
      "id": "03-02_variable_length_window",
      "title": "03-2. 不定長滑動視窗",
      "description": "可變窗口大小的滑動視窗技巧與經典題目",
      "tags": [
        "Sliding Window",
        "Variable Length",
        "不定長視窗"
      ],
      "folder": "03",
      "slug": "02_variable_length_window",
      "path": "/articles/03/02_variable_length_window",
      "excerpt": "不定長滑動視窗 (Variable-Length Sliding Window) 核心概念 不定長滑動視窗指的是窗口大小可變，根據條件動態調整左右邊界。 特點 - 窗口大小動態變化 - 使用 `left` 和 `right` 兩個指針 - `right` 向右擴展，`left` 向右收縮 - 時間複雜度：O(n) - 適合求「滿足某條件的最長/最短子陣列」 --- 通用模板 模板說明 1. 右指針",
      "order": 2,
      "draft": false
    },
    {
      "id": "03-03_opposite_two_pointers",
      "title": "03-3. 雙向雙指針",
      "description": "對撞指針技巧與經典題目",
      "tags": [
        "Two Pointers",
        "Opposite Direction",
        "雙向指針",
        "對撞指針"
      ],
      "folder": "03",
      "slug": "03_opposite_two_pointers",
      "path": "/articles/03/03_opposite_two_pointers",
      "excerpt": "雙向雙指針 (Opposite Direction Two Pointers) 核心概念 雙向雙指針（又稱對撞指針）是指兩個指針從陣列兩端出發，相向移動，直到相遇。 特點 - 兩個指針：`left` 從左端，`right` 從右端 - 相向移動：`left++`、`right--` - 終止條件：`left < right` 或 `left <= right` - 時間複雜度：O(n) - 通常需",
      "order": 3,
      "draft": false
    },
    {
      "id": "03-04_same_direction_two_pointers",
      "title": "03-4. 同向雙指針",
      "description": "快慢指針技巧與經典題目",
      "tags": [
        "Two Pointers",
        "Same Direction",
        "同向指針",
        "快慢指針"
      ],
      "folder": "03",
      "slug": "04_same_direction_two_pointers",
      "path": "/articles/03/04_same_direction_two_pointers",
      "excerpt": "同向雙指針 (Same Direction Two Pointers) 核心概念 同向雙指針（又稱快慢指針）是指兩個指針從同一端出發，同向移動，但移動速度或條件不同。 特點 - 兩個指針：`slow` 和 `fast` - 同向移動：都向右（或都向左） - 移動速度：fast 通常比 slow 快 - 時間複雜度：O(n) - 適合原地修改、鏈表問題 --- 通用模板 模板 1：原地修改陣列 模板",
      "order": 4,
      "draft": false
    },
    {
      "id": "04-00_introduction",
      "title": "04-0. 二分法介紹",
      "description": "二分搜尋的核心概念、模板與應用場景",
      "tags": [
        "Binary Search",
        "二分搜尋",
        "二分法"
      ],
      "folder": "04",
      "slug": "00_introduction",
      "path": "/articles/04/00_introduction",
      "excerpt": "二分法介紹 核心概念 二分搜尋 (Binary Search) 是一種在有序資料中快速查找目標值的演算法。 基本原理 每次將搜尋範圍縮小一半，直到找到目標或確定不存在。 時間複雜度 - 最佳：O(1)（第一次就找到） - 平均：O(log n) - 最差：O(log n) 為什麼是 O(log n)？ - 每次範圍減半：n → n/2 → n/4 → ... → 1 - 需要 log₂(n) 次操",
      "order": 0,
      "draft": false
    },
    {
      "id": "04-01_basic_search",
      "title": "04-1. 基礎查找",
      "description": "二分搜尋的基礎應用：查找元素、插入位置、邊界查找",
      "tags": [
        "Binary Search",
        "Basic Search",
        "基礎查找"
      ],
      "folder": "04",
      "slug": "01_basic_search",
      "path": "/articles/04/01_basic_search",
      "excerpt": "基礎查找 (Basic Search) 核心概念 基礎查找是二分搜尋最直接的應用，包括： 1. 查找確切的元素 2. 查找插入位置 3. 查找左右邊界 --- 場景 1：查找元素是否存在 問題：Binary Search 題目：LeetCode 704 在升序陣列中查找 target，存在返回索引，不存在返回 -1。 時間複雜度：O(log n) 空間複雜度：O(1) --- 場景 2：查找插入位",
      "order": 1,
      "draft": false
    },
    {
      "id": "04-02_binary_search_on_answer",
      "title": "04-2. 二分猜答案",
      "description": "將優化問題轉化為判定問題，使用二分搜尋猜測最優解",
      "tags": [
        "Binary Search",
        "Binary Search on Answer",
        "二分猜答案"
      ],
      "folder": "04",
      "slug": "02_binary_search_on_answer",
      "path": "/articles/04/02_binary_search_on_answer",
      "excerpt": "二分猜答案 (Binary Search on Answer) 核心概念 二分猜答案是指：當問題的答案具有單調性時，可以通過二分搜尋來「猜測」答案，並驗證其可行性。 基本思路 1. 確定答案範圍 [left, right] 2. 猜測答案 mid 3. 驗證可行性 check(mid) 4. 縮小範圍：    - 可行 → 嘗試更優解    - 不可行 → 調整範圍 適用條件 1. 答案有範圍：最",
      "order": 2,
      "draft": false
    },
    {
      "id": "04-03_kth_element",
      "title": "04-3. 第 K 小/大元素",
      "description": "使用二分搜尋、快速選擇和堆找第 K 小/大元素",
      "tags": [
        "Binary Search",
        "Kth Element",
        "Quick Select",
        "Heap"
      ],
      "folder": "04",
      "slug": "03_kth_element",
      "path": "/articles/04/03_kth_element",
      "excerpt": "第 K 小/大元素 (Kth Element) 核心概念 找第 K 小/大元素是經典問題，有多種解法： 1. 排序：O(n log n) 2. 堆 (Heap)：O(n log k) 3. 快速選擇 (Quick Select)：O(n) 平均，O(n²) 最差 4. 二分搜尋：O(n log(範圍)) --- 方法 1：排序 最直接的方法 時間複雜度：O(n log n) 空間複雜度：O(1) ",
      "order": 3,
      "draft": false
    },
    {
      "id": "05-00_introduction",
      "title": "05-0. LinkedList, Binary Tree, Tree 介紹",
      "description": "鏈表與樹的基本概念、術語與結構類型",
      "tags": [
        "LinkedList",
        "Binary Tree",
        "Tree",
        "基礎概念"
      ],
      "folder": "05",
      "slug": "00_introduction",
      "path": "/articles/05/00_introduction",
      "excerpt": "LinkedList, Binary Tree, Tree 介紹 前言 LinkedList（鏈表） 和 Tree（樹） 是兩種最重要的非連續儲存結構，與陣列的連續儲存不同，它們通過指針連接節點。 --- 鏈表基本概念 節點 (Node) 鏈表的基本單位，包含資料和指針。 鏈表類型 1. 單向鏈表 (Singly Linked List) 特點： - 只能單向遍歷 - 節點只有 next 指針 -",
      "order": 0,
      "draft": false
    },
    {
      "id": "05-01_basic_operations",
      "title": "05-1. 基礎操作",
      "description": "深入介紹鏈表的基本操作，包含新增、刪除、反轉、合併等核心技巧。透過 LeetCode 經典題目學習雙指針、快慢指針、虛擬節點等實用技巧，掌握鏈表操作的時間與空間複雜度分析。",
      "tags": [
        "Linked List",
        "Two Pointers",
        "鏈表",
        "雙指針",
        "LeetCode"
      ],
      "folder": "05",
      "slug": "01_basic_operations",
      "path": "/articles/05/01_basic_operations",
      "excerpt": "Linked List 基礎操作 1. Reverse Linked List 1.1 迭代法 反轉鏈表的核心思想是改變每個節點的指向。 時間複雜度: O(n) 空間複雜度: O(1) 1.2 遞迴法 時間複雜度: O(n) 空間複雜度: O(n) - 遞迴調用棧 1.3 反轉區間 [m, n] 2. Node Deletion 2.1 刪除指定值的節點 2.2 刪除倒數第 N 個節點 2.3 刪",
      "order": 1,
      "draft": false
    },
    {
      "id": "05-02_lru_lfu_cache",
      "title": "05-2. LRU/LFU Cache",
      "description": "完整解析 LRU 與 LFU 緩存淘汰策略的實作方法。使用雙向鏈表與哈希表實現 O(1) 時間複雜度的緩存操作，深入理解 get、put 操作的設計原理與優化技巧。",
      "tags": [
        "LRU",
        "LFU",
        "Cache",
        "Hash Map",
        "Doubly Linked List",
        "緩存",
        "哈希表"
      ],
      "folder": "05",
      "slug": "02_lru_lfu_cache",
      "path": "/articles/05/02_lru_lfu_cache",
      "excerpt": "LRU/LFU Cache 1. LRU Cache (Least Recently Used) 1.1 原理 LRU Cache 淘汰最久未使用的數據。需要支持： - O(1) 時間獲取數據 - O(1) 時間插入/更新數據 - 當容量滿時，刪除最久未使用的數據 數據結構： - HashMap：存儲 key 到節點的映射 - Doubly Linked List：維護使用順序（最近使用的在頭部，",
      "order": 2,
      "draft": false
    },
    {
      "id": "05-03_skip_list",
      "title": "05-3. Skip List",
      "description": "探索跳躍串列的設計原理與實作細節。理解多層索引結構如何實現 O(log n) 的搜尋、插入、刪除操作，以及隨機化層數的機率分析與實際應用場景。",
      "tags": [
        "Skip List",
        "Data Structure",
        "跳躍串列",
        "資料結構",
        "Probabilistic"
      ],
      "folder": "05",
      "slug": "03_skip_list",
      "path": "/articles/05/03_skip_list",
      "excerpt": "Skip List (跳表) 1. 基本概念 Skip List 是一種隨機化的數據結構，可以在 O(log n) 時間內完成查找、插入和刪除操作。它是平衡樹的一種替代方案，實現更簡單但性能相當。 1.1 為什麼需要 Skip List？ 有序鏈表的問題： 查找元素需要 O(n) 時間。 Skip List 的解決方案： 通過建立多層索引，實現類似二分查找的效果。 1.2 核心思想 1. 多層鏈表",
      "order": 3,
      "draft": false
    },
    {
      "id": "05-04_binary_tree",
      "title": "05-4. Binary Tree",
      "description": "全面掌握二元樹的基礎知識與遍歷技巧。包含前序、中序、後序遍歷的遞迴與迭代實作，以及層序遍歷、路徑問題、樹的構造等經典題型解析。",
      "tags": [
        "Binary Tree",
        "Tree Traversal",
        "DFS",
        "BFS",
        "二元樹",
        "樹遍歷"
      ],
      "folder": "05",
      "slug": "04_binary_tree",
      "path": "/articles/05/04_binary_tree",
      "excerpt": "Binary Tree (二元樹) 1. 基本概念 1.1 定義 二元樹是每個節點最多有兩個子節點的樹結構。 1.2 基本術語 - 根節點 (Root): 1 - 葉節點 (Leaf): 4, 5, 6 - 深度 (Depth): 節點到根的路徑長度 - 高度 (Height): 節點到最深葉節點的路徑長度 - 層級 (Level): 深度 + 1 2. 樹的遍歷 2.1 前序遍歷 (Preord",
      "order": 4,
      "draft": false
    },
    {
      "id": "05-05_tree",
      "title": "05-5. Tree",
      "description": "深入探討各種樹形資料結構，包含二元搜尋樹（BST）、平衡樹（AVL）、紅黑樹等進階主題。理解樹的性質、操作複雜度，以及在實際應用中的選擇與權衡。",
      "tags": [
        "Tree",
        "BST",
        "AVL",
        "Red-Black Tree",
        "樹",
        "平衡樹"
      ],
      "folder": "05",
      "slug": "05_tree",
      "path": "/articles/05/05_tree",
      "excerpt": "Tree (樹) 1. General Tree (一般樹) 1.1 N-ary Tree (N 叉樹) 每個節點可以有任意數量的子節點。 N 叉樹的遍歷 N 叉樹的最大深度 2. Binary Search Tree (BST) 2.1 BST 性質 對於 BST 中的每個節點： - 左子樹所有節點的值 < 當前節點的值 - 右子樹所有節點的值 > 當前節點的值 - 左右子樹也都是 BST 2.",
      "order": 5,
      "draft": false
    },
    {
      "id": "05-06_tree_backtracking",
      "title": "05-6. Tree + Backtracking",
      "description": "結合樹形結構與回溯算法，解決路徑搜尋、組合問題、決策樹等經典題型。掌握樹上回溯的模板與技巧，學習如何在樹中尋找所有可能的解。",
      "tags": [
        "Tree",
        "Backtracking",
        "Path Sum",
        "DFS",
        "樹",
        "回溯"
      ],
      "folder": "05",
      "slug": "06_tree_backtracking",
      "path": "/articles/05/06_tree_backtracking",
      "excerpt": "Tree + Backtracking (樹 + 回溯) 1. 基本概念 樹的回溯問題通常涉及： - 尋找從根到葉的所有路徑 - 尋找滿足特定條件的路徑 - 路徑和問題 - 組合問題 回溯模板： 2. 路徑和問題 2.1 路徑總和 II 找出所有從根到葉且節點值之和等於目標和的路徑。 時間複雜度: O(n²)，最壞情況需要複製 n 條路徑，每條路徑長度為 O(n) 空間複雜度: O(n)，遞迴調用",
      "order": 6,
      "draft": false
    },
    {
      "id": "06-00_introduction",
      "title": "06-0. Stack, Queue, Deque, 單調棧介紹",
      "description": "完整介紹堆疊、佇列、雙端佇列與單調棧的概念與實作。從基本操作到進階應用，理解 LIFO、FIFO 特性，掌握單調棧解決 Next Greater Element 等經典問題的核心技巧。",
      "tags": [
        "Stack",
        "Queue",
        "Deque",
        "Monotonic Stack",
        "堆疊",
        "佇列",
        "單調棧"
      ],
      "folder": "06",
      "slug": "00_introduction",
      "path": "/articles/06/00_introduction",
      "excerpt": "Stack, Queue, Deque, 單調棧介紹 Stack（棧） 基本概念 Stack 是一種 LIFO (Last In First Out) 資料結構，最後放入的元素最先被取出。 STL `std::stack` 用法 Stack 的實作方式 1. 基於陣列的實作 時間複雜度： - Push: O(1) amortized - Pop: O(1) - Top: O(1) 2. 基於鏈表的",
      "order": 0,
      "draft": false
    },
    {
      "id": "06-01_iterative_dfs",
      "title": "06-1. Iteration DFS (stack)",
      "description": "使用堆疊實現迭代式深度優先搜尋（DFS），避免遞迴造成的堆疊溢出問題。學習前序、中序、後序遍歷的迭代實作，以及在圖與樹中應用迭代 DFS 的技巧。",
      "tags": [
        "Stack",
        "DFS",
        "Iterative",
        "Tree Traversal",
        "堆疊",
        "深度優先搜尋"
      ],
      "folder": "06",
      "slug": "01_iterative_dfs",
      "path": "/articles/06/01_iterative_dfs",
      "excerpt": "Iteration DFS (Stack) 概述 深度優先搜尋（DFS）通常使用遞迴實作，但也可以使用 Stack 來實現非遞迴版本。使用 Stack 的迭代式 DFS 在某些情況下更有優勢： 1. 避免棧溢出：遞迴深度太大時會導致 Stack Overflow 2. 更靈活的控制：可以隨時暫停、恢復搜尋 3. 易於理解：顯式地使用 Stack，更清晰地看到調用過程 遞迴 DFS vs 迭代 DF",
      "order": 1,
      "draft": false
    },
    {
      "id": "06-02_next_greater_element",
      "title": "06-2. 下一個更大元素 (Next Greater Element)",
      "description": "掌握單調棧解決 Next Greater Element 問題的核心技巧。從暴力解法到 O(n) 優化，理解單調遞減棧的工作原理，並應用於循環陣列、溫度預測、股票跨度等經典題型。",
      "tags": [
        "Monotonic Stack",
        "Next Greater Element",
        "LeetCode",
        "單調棧",
        "陣列"
      ],
      "folder": "06",
      "slug": "02_next_greater_element",
      "path": "/articles/06/02_next_greater_element",
      "excerpt": "下一個更大元素 (Next Greater Element) 核心概念 Next Greater Element (NGE) 問題：給定一個陣列，對於每個元素，找到它右邊第一個比它大的元素。 暴力解法的問題 問題： 時間複雜度 O(n²)，效率太低。 單調棧優化 使用單調遞減棧可以將時間複雜度優化到 O(n)。 核心思想： - 維護一個從棧底到棧頂遞減的棧 - 當遇到一個更大的元素時，棧中所有小於",
      "order": 2,
      "draft": false
    },
    {
      "id": "06-03_rectangle_area",
      "title": "06-3. 矩形面積 (Rectangle Area)",
      "description": "使用單調棧解決柱狀圖最大矩形、二維矩陣最大矩形等幾何問題。深入理解如何透過單調遞增棧找到左右邊界，實現 O(n) 時間複雜度的高效算法。",
      "tags": [
        "Monotonic Stack",
        "Rectangle",
        "Histogram",
        "DP",
        "單調棧",
        "矩形",
        "動態規劃"
      ],
      "folder": "06",
      "slug": "03_rectangle_area",
      "path": "/articles/06/03_rectangle_area",
      "excerpt": "矩形面積 (Rectangle Area) 概述 單調棧在計算矩形面積問題中有重要應用，特別是： 1. 柱狀圖中最大矩形 2. 二維矩陣中最大矩形 3. 最大正方形 這些問題都可以通過單調棧高效解決。 --- LeetCode 84: Largest Rectangle in Histogram 問題： 給定 n 個非負整數表示柱狀圖中各個柱子的高度，每個柱子寬度為 1，求柱狀圖中最大矩形的面積。",
      "order": 3,
      "draft": false
    },
    {
      "id": "06-04_lru_lfu_design",
      "title": "06-4. LRU 與 LFU Cache 設計",
      "description": "使用 Stack、Queue、Deque 實現 LRU 與 LFU 緩存淘汰策略。深入理解雙向鏈表與哈希表結合的設計技巧，實現 O(1) 時間複雜度的高效緩存系統。",
      "tags": [
        "LRU",
        "LFU",
        "Cache",
        "Design",
        "Hash Map",
        "Doubly Linked List",
        "緩存設計"
      ],
      "folder": "06",
      "slug": "04_lru_lfu_design",
      "path": "/articles/06/04_lru_lfu_design",
      "excerpt": "LRU 與 LFU Cache 設計 概述 Cache（緩存）是計算機系統中用於加速數據訪問的重要組件。當緩存空間有限時，需要緩存淘汰策略來決定刪除哪些數據。 兩種常見策略： 1. LRU (Least Recently Used)：淘汰最久未使用的數據 2. LFU (Least Frequently Used)：淘汰使用頻率最低的數據 這兩種設計都與 Stack、Queue、Deque 的思想",
      "order": 4,
      "draft": false
    },
    {
      "id": "06-05_design_problems",
      "title": "06-5. 其他常見設計題",
      "description": "深入探討使用 Stack、Queue、Deque 解決的經典設計問題。包含最小棧、最大棧、滑動窗口最大值、實現隊列與棧的相互轉換等面試常見題型。",
      "tags": [
        "Design",
        "Stack",
        "Queue",
        "Min Stack",
        "Sliding Window",
        "Design Problems",
        "設計題"
      ],
      "folder": "06",
      "slug": "05_design_problems",
      "path": "/articles/06/05_design_problems",
      "excerpt": "其他常見設計題 概述 Stack 和 Queue 相關的設計題在面試中非常常見。這些題目考察： 1. 數據結構的靈活運用 2. 時間空間複雜度的權衡 3. 系統設計思維 本章將介紹常見的設計題型和解決方案。 --- LeetCode 155: Min Stack 問題描述 設計一個支持 push、pop、top 操作的棧，並能在常數時間內檢索到最小元素。 實現函數： - `push(x)`: 將元",
      "order": 5,
      "draft": false
    },
    {
      "id": "07-00_introduction",
      "title": "07-0. 網格圖的介紹",
      "description": "全面介紹網格圖的基本概念與遍歷技巧。學習四向/八向移動、邊界檢查、visited 陣列的使用，掌握 DFS 與 BFS 在網格圖中的應用模板與最佳實踐。",
      "tags": [
        "Grid",
        "Graph",
        "DFS",
        "BFS",
        "網格圖",
        "圖論"
      ],
      "folder": "07",
      "slug": "00_introduction",
      "path": "/articles/07/00_introduction",
      "excerpt": "網格圖的介紹 什麼是網格圖？ 網格圖（Grid Graph）是一種特殊的圖結構，通常用二維陣列表示。每個格子代表一個節點，相鄰的格子之間有邊相連。網格圖在演算法題目中非常常見，特別是在路徑搜尋、區域填充、島嶼問題等場景中。 與一般圖的區別 | 特性 | 一般圖 | 網格圖 | |------|--------|--------| | 表示方式 | 鄰接表、鄰接矩陣 | 二維陣列 | | 節點數量 ",
      "order": 0,
      "draft": false
    },
    {
      "id": "07-01_dfs_bfs_basics",
      "title": "07-1. DFS/BFS 基礎 (DFS/BFS Basics)",
      "description": "深入學習網格圖的 DFS 與 BFS 基礎應用。透過 Flood Fill、島嶼計數、最大面積等經典題目，掌握連通區域搜索、邊界處理、原地標記等實用技巧。",
      "tags": [
        "DFS",
        "BFS",
        "Grid",
        "Flood Fill",
        "Island",
        "深度優先",
        "廣度優先"
      ],
      "folder": "07",
      "slug": "01_dfs_bfs_basics",
      "path": "/articles/07/01_dfs_bfs_basics",
      "excerpt": "DFS/BFS 基礎 網格圖的 DFS 和 BFS 是最基礎也最重要的技巧，主要用於： - 連通區域的搜索（Flood Fill） - 島嶼問題（Number of Islands） - 面積計算（Max Area of Island） - 邊界處理（Surrounded Regions） 核心概念 DFS（深度優先搜索） - 特點：一條路走到底，回溯繼續 - 實現：遞迴或堆疊 - 適用：連通性判",
      "order": 1,
      "draft": false
    },
    {
      "id": "07-02_backtracking",
      "title": "07-2. Backtracking",
      "description": "結合網格圖與回溯算法，解決單詞搜索、路徑規劃等複雜問題。學習狀態恢復、剪枝優化、Trie 樹加速等進階技巧，掌握在網格中搜索所有可能解的方法。",
      "tags": [
        "Backtracking",
        "Grid",
        "Word Search",
        "DFS",
        "Trie",
        "回溯",
        "網格圖"
      ],
      "folder": "07",
      "slug": "02_backtracking",
      "path": "/articles/07/02_backtracking",
      "excerpt": "Backtracking 回溯（Backtracking）是在網格圖中搜索所有可能路徑的重要技巧。與普通的 DFS 不同，回溯需要： 1. 嘗試所有可能的選擇 2. 在遞迴返回時恢復狀態（撤銷選擇） 3. 通常需要找到所有解或最優解 核心模板 LeetCode 79: Word Search 題目描述 給定一個 m × n 的字符網格和一個字符串 word，判斷 word 是否存在於網格中。單詞必",
      "order": 2,
      "draft": false
    },
    {
      "id": "07-03_multi_source_bfs",
      "title": "07-3. Multi-source BFS, 狀態空間 BFS",
      "description": "掌握多源 BFS 與狀態空間 BFS 的進階技巧。學習如何同時從多個起點擴展、計算到最近源點的距離，以及在狀態空間中進行搜索的方法與應用。",
      "tags": [
        "Multi-source BFS",
        "State Space",
        "Distance",
        "Shortest Bridge",
        "多源BFS",
        "狀態空間"
      ],
      "folder": "07",
      "slug": "03_multi_source_bfs",
      "path": "/articles/07/03_multi_source_bfs",
      "excerpt": "Multi-source BFS, 狀態空間 BFS 多源 BFS（Multi-source BFS） 核心思想 普通 BFS 從單一源點開始擴展，而多源 BFS 同時從多個源點開始擴展。這在計算「到最近源點的距離」時特別有用。 技巧 將所有源點同時加入初始隊列，然後執行標準 BFS。這樣每個點到達的時間就是它到最近源點的距離。 模板 --- LeetCode 542: 01 Matrix 題目描",
      "order": 3,
      "draft": false
    },
    {
      "id": "07-04_shortest_path",
      "title": "07-4. 最短路徑 (Shortest Path)",
      "description": "完整解析網格圖的最短路徑算法。從 BFS 到 Dijkstra，學習無權圖、帶權圖的最短路徑求解，掌握最小化最大值、最大化最小值等變形問題的解法。",
      "tags": [
        "Shortest Path",
        "Dijkstra",
        "BFS",
        "Graph",
        "Binary Search",
        "最短路徑",
        "Dijkstra算法"
      ],
      "folder": "07",
      "slug": "04_shortest_path",
      "path": "/articles/07/04_shortest_path",
      "excerpt": "最短路徑 (Shortest Path) 網格圖的最短路徑問題是圖論中的經典問題。根據邊的權重不同，需要使用不同的算法： - 無權圖或等權圖：BFS - 帶權圖（非負權重）：Dijkstra - 帶權圖（可能有負權重）：Bellman-Ford（網格圖中較少見） BFS 求最短路徑 原理 在無權圖或等權圖中，BFS 保證第一次到達目標點時的路徑就是最短路徑。 模板 --- LeetCode 109",
      "order": 4,
      "draft": false
    },
    {
      "id": "08-00_introduction",
      "title": "08-0. 圖論介紹",
      "description": "圖的基本概念、表示方式與術語",
      "tags": [
        "graph",
        "基礎概念"
      ],
      "folder": "08",
      "slug": "00_introduction",
      "path": "/articles/08/00_introduction",
      "excerpt": "圖論介紹 圖論 (Graph Theory) 是研究圖 (Graph) 及其性質的數學分支，在計算機科學中有廣泛應用，包括社交網路分析、路徑規劃、網路流量優化等。 基本概念 什麼是圖？ 圖 (Graph) 是由頂點 (Vertex/Node) 和邊 (Edge) 組成的數據結構，記作 `G = (V, E)`： - `V`: 頂點集合 - `E`: 邊集合 圖的分類 1. 有向圖 vs 無向圖 無",
      "order": 0,
      "draft": false
    },
    {
      "id": "08-01_dfs_bfs_cycle",
      "title": "08-1. DFS/BFS 與環檢測",
      "description": "深度優先搜尋、廣度優先搜尋與圖的環檢測",
      "tags": [
        "graph",
        "DFS",
        "BFS",
        "cycle detection"
      ],
      "folder": "08",
      "slug": "01_dfs_bfs_cycle",
      "path": "/articles/08/01_dfs_bfs_cycle",
      "excerpt": "DFS/BFS 與環檢測 圖的遍歷是圖論中最基本也最重要的操作。本章將介紹兩種主要的遍歷方法：深度優先搜尋 (DFS) 和廣度優先搜尋 (BFS)，以及如何使用它們來檢測圖中的環。 深度優先搜尋 (DFS) DFS 沿著一條路徑盡可能深入，直到無法繼續時回溯。 DFS 特性 - 策略：一直往深處走，走不通再回頭 - 數據結構：Stack（或遞迴調用棧） - 應用：路徑搜尋、環檢測、拓撲排序、連通分",
      "order": 1,
      "draft": false
    },
    {
      "id": "08-02_union_find",
      "title": "08-2. 並查集 (Union Find)",
      "description": "高效處理集合合併與查詢的資料結構",
      "tags": [
        "graph",
        "union find",
        "disjoint set"
      ],
      "folder": "08",
      "slug": "02_union_find",
      "path": "/articles/08/02_union_find",
      "excerpt": "並查集 (Union Find) 並查集 (Union Find)，也稱為 Disjoint Set Union (DSU)，是一種用於處理不相交集合的合併和查詢問題的資料結構。 核心概念 問題場景 並查集主要解決以下問題： 1. 合併 (Union)：將兩個集合合併為一個 2. 查詢 (Find)：判斷兩個元素是否在同一個集合中 應用場景 - 連通性問題：判斷圖中兩點是否連通 - 環檢測：檢測無",
      "order": 2,
      "draft": false
    },
    {
      "id": "08-03_topological_sort",
      "title": "08-3. 拓撲排序 (Topological Sort)",
      "description": "有向無環圖的線性排序 - Kahn 演算法與 DFS 方法",
      "tags": [
        "graph",
        "topological sort",
        "DAG",
        "Kahn algorithm"
      ],
      "folder": "08",
      "slug": "03_topological_sort",
      "path": "/articles/08/03_topological_sort",
      "excerpt": "拓撲排序 (Topological Sort) 拓撲排序是將有向無環圖 (DAG) 的所有頂點排成一個線性序列，使得對於任意有向邊 (u, v)，u 都排在 v 之前。 基本概念 什麼是拓撲排序？ 拓撲排序是 DAG 的一種線性排序，滿足： - 如果存在邊 u → v，則 u 在 v 前面 - 只有 DAG 才有拓撲排序（有環則無解） - 拓撲排序可能不唯一 應用場景 1. 任務排程：確定任務的執",
      "order": 3,
      "draft": false
    },
    {
      "id": "08-04_dijkstra",
      "title": "08-4. Dijkstra 最短路徑演算法",
      "description": "單源最短路徑的貪心演算法",
      "tags": [
        "graph",
        "shortest path",
        "dijkstra",
        "greedy",
        "priority queue"
      ],
      "folder": "08",
      "slug": "04_dijkstra",
      "path": "/articles/08/04_dijkstra",
      "excerpt": "Dijkstra 最短路徑演算法 Dijkstra 演算法是解決單源最短路徑 (Single-Source Shortest Path) 問題的經典貪心演算法，由荷蘭計算機科學家 Edsger Dijkstra 於 1956 年提出。 核心概念 問題定義 給定帶權重的有向圖，找出從源點 (source) 到所有其他頂點的最短路徑。 限制：邊的權重必須非負 (≥ 0)。 基本思想 採用貪心策略： 1",
      "order": 4,
      "draft": false
    },
    {
      "id": "08-05_bellman_ford",
      "title": "08-5. Bellman-Ford 演算法",
      "description": "支援負權邊的單源最短路徑演算法",
      "tags": [
        "graph",
        "shortest path",
        "bellman-ford",
        "negative edge",
        "dynamic programming"
      ],
      "folder": "08",
      "slug": "05_bellman_ford",
      "path": "/articles/08/05_bellman_ford",
      "excerpt": "Bellman-Ford 演算法 Bellman-Ford 演算法是另一種解決單源最短路徑問題的演算法，與 Dijkstra 的主要區別在於它可以處理負權邊，並且能夠檢測負環。 核心概念 問題定義 給定帶權重的有向圖（可能有負權邊），找出從源點到所有其他頂點的最短路徑。 優勢： - 支持負權邊 - 可以檢測負環（存在負環時無最短路徑） 劣勢： - 時間複雜度較高：O(VE) 基本思想 採用動態規劃",
      "order": 5,
      "draft": false
    },
    {
      "id": "08-06_spfa",
      "title": "08-6. SPFA 演算法",
      "description": "Bellman-Ford 的隊列優化 - Shortest Path Faster Algorithm",
      "tags": [
        "graph",
        "shortest path",
        "SPFA",
        "queue optimization"
      ],
      "folder": "08",
      "slug": "06_spfa",
      "path": "/articles/08/06_spfa",
      "excerpt": "SPFA (Shortest Path Faster Algorithm) SPFA (Shortest Path Faster Algorithm) 是 Bellman-Ford 演算法的隊列優化版本，由中國學者段凡丁於 1994 年提出。它在平均情況下比 Bellman-Ford 快得多，但最壞時間複雜度仍為 O(VE)。 核心概念 與 Bellman-Ford 的關係 Bellman-For",
      "order": 6,
      "draft": false
    },
    {
      "id": "08-07_floyd_warshall",
      "title": "08-7. Floyd-Warshall 演算法",
      "description": "全源最短路徑的動態規劃解法",
      "tags": [
        "graph",
        "shortest path",
        "floyd-warshall",
        "all-pairs",
        "dynamic programming"
      ],
      "folder": "08",
      "slug": "07_floyd_warshall",
      "path": "/articles/08/07_floyd_warshall",
      "excerpt": "Floyd-Warshall 演算法 Floyd-Warshall 演算法是解決全源最短路徑 (All-Pairs Shortest Path) 問題的經典動態規劃演算法,可以一次計算出圖中任意兩點之間的最短距離。 核心概念 問題定義 給定帶權重的有向圖（可能有負權邊），找出所有節點對之間的最短路徑。 輸入：圖的鄰接矩陣 輸出：dist[i][j] 表示從節點 i 到節點 j 的最短距離 基本思想",
      "order": 7,
      "draft": false
    },
    {
      "id": "08-08_tarjan",
      "title": "08-8. Tarjan 演算法",
      "description": "強連通分量、橋與割點的統一解法",
      "tags": [
        "graph",
        "tarjan",
        "SCC",
        "bridge",
        "articulation point",
        "DFS"
      ],
      "folder": "08",
      "slug": "08_tarjan",
      "path": "/articles/08/08_tarjan",
      "excerpt": "Tarjan 演算法 Tarjan 演算法是由 Robert Tarjan 提出的一系列基於 DFS 的圖論演算法,主要用於解決強連通分量 (SCC)、橋 (Bridge) 和割點 (Articulation Point) 問題。 核心概念 1. 強連通分量 (Strongly Connected Component, SCC) 定義：有向圖中的極大強連通子圖。 - 強連通：任意兩個頂點之間都有路",
      "order": 8,
      "draft": false
    },
    {
      "id": "08-09_kruskal_prim",
      "title": "08-9. 最小生成樹 - Kruskal & Prim",
      "description": "連接所有節點的最小代價 - 兩種經典 MST 演算法",
      "tags": [
        "graph",
        "MST",
        "kruskal",
        "prim",
        "greedy",
        "union find"
      ],
      "folder": "08",
      "slug": "09_kruskal_prim",
      "path": "/articles/08/09_kruskal_prim",
      "excerpt": "最小生成樹 (Minimum Spanning Tree, MST) 最小生成樹是圖論中的經典問題，目標是找到連接圖中所有節點的最小權重樹。 核心概念 什麼是生成樹？ 生成樹 (Spanning Tree)： - 包含圖中所有頂點的樹 - 恰好有 V-1 條邊（V 為頂點數） - 連通且無環 最小生成樹 (MST)： - 所有生成樹中，邊權重和最小的那棵 視覺化範例 性質 1. 唯一性：權重不同時",
      "order": 9,
      "draft": false
    },
    {
      "id": "08-10_max_flow",
      "title": "08-10. 最大流演算法 (進階)",
      "description": "網路流問題 - Edmonds-Karp 與 Dinic 演算法",
      "tags": [
        "graph",
        "max flow",
        "network flow",
        "edmonds-karp",
        "dinic",
        "advanced"
      ],
      "folder": "08",
      "slug": "10_max_flow",
      "path": "/articles/08/10_max_flow",
      "excerpt": "最大流演算法 (Maximum Flow) 最大流問題是圖論中的經典問題，用於計算從源點到匯點可以傳輸的最大流量。本章介紹兩種經典演算法：Edmonds-Karp 和 Dinic。 > 注意：這是進階主題，在 LeetCode 中較少出現。本章著重於概念介紹和基本實現。 核心概念 網路流 (Network Flow) 流網路由以下元素組成： - 有向圖 G = (V, E) - 容量 c(u, v",
      "order": 10,
      "draft": false
    },
    {
      "id": "08-11_bipartite_matching",
      "title": "08-11. 二分圖最大匹配 (進階)",
      "description": "二分圖判定與最大匹配 - 匈牙利演算法與 Hopcroft-Karp",
      "tags": [
        "graph",
        "bipartite",
        "matching",
        "hungarian algorithm",
        "hopcroft-karp",
        "advanced"
      ],
      "folder": "08",
      "slug": "11_bipartite_matching",
      "path": "/articles/08/11_bipartite_matching",
      "excerpt": "二分圖最大匹配 二分圖最大匹配是圖論中的經典問題，用於尋找二分圖中最多的不相交匹配邊。本章介紹二分圖的基本概念、判定方法和匹配演算法。 > 注意：這是進階主題，最大匹配演算法在 LeetCode 較少出現，但二分圖判定是常見題型。 核心概念 二分圖 (Bipartite Graph) 定義：頂點可以分為兩個集合 U 和 V，使得： - 同一集合內的頂點之間沒有邊 - 所有邊都連接 U 和 V 中的",
      "order": 11,
      "draft": false
    },
    {
      "id": "08-12_shortest_path_comparison",
      "title": "08-12. 最短路徑算法比較：四種解法實戰",
      "description": "透過 LeetCode 1334 題比較 Floyd-Warshall、Dijkstra、SPFA、Bellman-Ford 四種最短路徑算法的性能差異",
      "tags": [
        "graph",
        "shortest path",
        "floyd-warshall",
        "dijkstra",
        "spfa",
        "bellman-ford",
        "comparison"
      ],
      "folder": "08",
      "slug": "12_shortest_path_comparison",
      "path": "/articles/08/12_shortest_path_comparison",
      "excerpt": "最短路徑算法比較：四種解法實戰 題目：Find the City With the Smallest Number of Neighbors at a Threshold Distance LeetCode 1334 給定 `n` 個城市和一些邊,找出在距離閾值內可到達城市數量最少的城市。如果有多個答案,返回編號最大的城市。 解題思路 這道題需要計算所有城市對之間的最短距離,然後統計每個城市在閾值",
      "order": 12,
      "draft": false
    },
    {
      "id": "09-00_introduction",
      "title": "09-0. 位元運算介紹",
      "description": "位元運算的基礎概念與術語",
      "tags": [
        "bit manipulation",
        "binary",
        "基礎"
      ],
      "folder": "09",
      "slug": "00_introduction",
      "path": "/articles/09/00_introduction",
      "excerpt": "0. 位元運算介紹 位元運算 (Bit Manipulation) 是直接在二進制位元層級上進行的運算，是電腦科學中最基礎且高效的運算方式之一。 Byte 介紹 在電腦中，資料的最小單位是 bit（位元），而 byte（位元組）是由 8 個 bits 組成： 常見的資料型態大小： - `char`: 1 byte (8 bits) - `short`: 2 bytes (16 bits) - `i",
      "order": 0,
      "draft": false
    },
    {
      "id": "09-01_bitwise_operations",
      "title": "09-1. Bitwise Operations",
      "description": "基本位元運算子與常用技巧",
      "tags": [
        "bit manipulation",
        "bitwise operators",
        "基礎"
      ],
      "folder": "09",
      "slug": "01_bitwise_operations",
      "path": "/articles/09/01_bitwise_operations",
      "excerpt": "1. Bitwise Operations (基本位元運算) 位元運算子是直接對二進制位元進行操作的運算子，是所有位元操作的基礎。 基本運算子 1. AND 運算子 (`&`) 規則：兩個位元都是 1 時，結果才是 1。 範例： 常見用途： - 提取特定位元 - 清除特定位元 - 檢查位元是否為 1 2. OR 運算子 (`|`) 規則：兩個位元中有一個是 1 時，結果就是 1。 範例： 常見用途",
      "order": 1,
      "draft": false
    },
    {
      "id": "09-02_advanced_bitwise",
      "title": "09-2. Advanced Bitwise Operations",
      "description": "進階位元運算技巧：位元遮罩、漢明距離、子集枚舉",
      "tags": [
        "bit manipulation",
        "bitmask",
        "subset enumeration",
        "進階"
      ],
      "folder": "09",
      "slug": "02_advanced_bitwise",
      "path": "/articles/09/02_advanced_bitwise",
      "excerpt": "2. Advanced Bitwise Operations (進階位元運算) 在掌握基本位元運算後，我們來學習更進階的技巧，包括位元遮罩、漢明距離和子集枚舉。 Bit Masking (位元遮罩) 位元遮罩是使用特定的位元模式來操作或檢查特定位元的技術。 基本操作 1. 設定特定位元 (Set Bit) 將第 `i` 位元設定為 1： 簡寫形式： 2. 清除特定位元 (Clear Bit) 將第",
      "order": 2,
      "draft": false
    },
    {
      "id": "09-03_bit_library",
      "title": "09-3. Bit Library - STL",
      "description": "C++ STL 位元函式庫：bitset 與 GCC Built-in Functions",
      "tags": [
        "bit manipulation",
        "bitset",
        "STL",
        "GCC builtin"
      ],
      "folder": "09",
      "slug": "03_bit_library",
      "path": "/articles/09/03_bit_library",
      "excerpt": "3. Bit Library - STL C++ 標準函式庫和編譯器提供了許多方便的位元操作工具，能夠大幅簡化位元運算的程式碼。 bitset<N> 容器 `bitset` 是 C++ STL 提供的固定大小的位元集合，提供了豐富的位元操作介面。 宣告與初始化 基本操作 1. set() - 設定位元 2. reset() - 清除位元 3. flip() - 翻轉位元 4. test() - 檢",
      "order": 3,
      "draft": false
    },
    {
      "id": "09-04_bitwise_tricks",
      "title": "09-4. Bitwise Tricks",
      "description": "常用的位元運算技巧與模式",
      "tags": [
        "bit manipulation",
        "tricks",
        "patterns",
        "進階"
      ],
      "folder": "09",
      "slug": "04_bitwise_tricks",
      "path": "/articles/09/04_bitwise_tricks",
      "excerpt": "4. Bitwise Tricks (位元運算技巧) 本章介紹一些經典且實用的位元運算技巧，這些技巧在演算法競賽和實際開發中都非常有用。 1. Number of 1 Bits (Brian Kernighan 演算法) 原理 Brian Kernighan 演算法是一種高效計算整數中 1 的個數的方法，其核心是利用 `x & (x - 1)` 可以移除最低位的 1。 實作 詳細過程 時間複雜度 ",
      "order": 4,
      "draft": false
    },
    {
      "id": "09-05_bit_dp",
      "title": "09-5. Bit DP",
      "description": "狀態壓縮動態規劃與位元字典樹",
      "tags": [
        "bit manipulation",
        "dynamic programming",
        "bitmask DP",
        "trie",
        "進階"
      ],
      "folder": "09",
      "slug": "05_bit_dp",
      "path": "/articles/09/05_bit_dp",
      "excerpt": "5. Bit DP (位元動態規劃) 位元 DP（Bitmask DP）是一種使用位元來表示狀態的動態規劃技術，特別適合處理集合相關的問題。 Bitmask DP (狀態壓縮 DP) 基本概念 當問題的狀態可以用一個小集合的子集來表示時，我們可以使用位元來編碼這些狀態，這樣可以： 1. 節省空間 2. 加速狀態轉移 3. 簡化程式碼 適用場景 - 集合元素數量較小（通常 n ≤ 20） - 需要枚",
      "order": 5,
      "draft": false
    },
    {
      "id": "10-00_introduction",
      "title": "10-0. 動態規劃介紹",
      "description": "動態規劃的核心概念與基礎原理",
      "tags": [
        "動態規劃",
        "DP",
        "狀態轉移",
        "記憶化搜索"
      ],
      "folder": "10",
      "slug": "00_introduction",
      "path": "/articles/10/00_introduction",
      "excerpt": "動態規劃介紹 動態規劃（Dynamic Programming，簡稱 DP）是一種通過將複雜問題分解為更簡單的子問題來解決問題的算法設計技術。它是演算法設計中最重要且最常用的技巧之一。 什麼是動態規劃？ 動態規劃的核心思想是：避免重複計算，將中間結果保存起來，以空間換時間。 > \"Those who cannot remember the past are condemned to repeat ",
      "order": 0,
      "draft": false
    },
    {
      "id": "10-01_one_dimensional_dp",
      "title": "10-1. 1 維 DP",
      "description": "一維動態規劃的經典問題與解法",
      "tags": [
        "動態規劃",
        "1D DP",
        "序列問題"
      ],
      "folder": "10",
      "slug": "01_one_dimensional_dp",
      "path": "/articles/10/01_one_dimensional_dp",
      "excerpt": "1 維 DP 1 維動態規劃是最基礎也是最常見的 DP 類型。在這類問題中，狀態通常只需要一個維度來表示，通常是 `dp[i]`，表示「到第 i 個位置」或「考慮前 i 個元素」時的最優解。 問題特徵 1. 問題涉及線性序列（數組、字符串等） 2. 決策只依賴於前面的狀態 3. 通常求解「前 i 個元素」的某種最優值或計數 4. 狀態轉移只需要考慮常數個前驅狀態 狀態定義模式 | 定義方式 | 含",
      "order": 1,
      "draft": false
    },
    {
      "id": "10-02_interval_dp",
      "title": "10-2. 區間 DP",
      "description": "區間動態規劃的經典問題與解法",
      "tags": [
        "動態規劃",
        "區間 DP",
        "Interval DP"
      ],
      "folder": "10",
      "slug": "02_interval_dp",
      "path": "/articles/10/02_interval_dp",
      "excerpt": "區間 DP (Interval DP) 區間 DP 是一種在區間 [i, j] 上進行決策的動態規劃問題。這類問題的核心思想是：將大區間的問題分解為小區間的子問題，通過枚舉分割點來合併子區間的解。 問題特徵 1. 問題涉及連續區間的最優解 2. 大區間的解可以由小區間的解合併得到 3. 需要枚舉分割點來決定如何劃分區間 4. 通常涉及區間合併、區間分割、回文串等概念 狀態定義 其中： - `i` ",
      "order": 2,
      "draft": false
    },
    {
      "id": "10-03_knapsack_01",
      "title": "10-3. 0-1 背包 DP",
      "description": "0-1 背包問題的原理與變形",
      "tags": [
        "動態規劃",
        "背包問題",
        "0-1 Knapsack"
      ],
      "folder": "10",
      "slug": "03_knapsack_01",
      "path": "/articles/10/03_knapsack_01",
      "excerpt": "0-1 背包 DP (0-1 Knapsack) 0-1 背包問題是動態規劃中最經典、最重要的問題之一。它不僅本身是一個重要的問題類型,更是許多 DP 問題的基礎模型。 問題描述 有 N 件物品和一個容量為 W 的背包。第 i 件物品的重量是 `w[i]`,價值是 `v[i]`。每件物品只能選擇一次(要麼拿,要麼不拿),求在不超過背包容量的前提下,能獲得的最大價值。 範例: 核心特徵 1. 每個物",
      "order": 3,
      "draft": false
    },
    {
      "id": "10-04_knapsack_unbounded",
      "title": "10-4. 完全背包",
      "description": "完全背包問題的原理與應用",
      "tags": [
        "動態規劃",
        "背包問題",
        "完全背包",
        "Unbounded Knapsack"
      ],
      "folder": "10",
      "slug": "04_knapsack_unbounded",
      "path": "/articles/10/04_knapsack_unbounded",
      "excerpt": "完全背包 (Unbounded Knapsack) 完全背包是背包問題的另一個重要變形。與 0-1 背包的區別在於:每個物品可以選擇無限次。 問題描述 有 N 種物品和一個容量為 W 的背包。第 i 種物品的重量是 `w[i]`,價值是 `v[i]`。每種物品可以選擇任意多次,求在不超過背包容量的前提下,能獲得的最大價值。 範例: 核心特徵 1. 每個物品可以選無限次 2. 有容量限制 3. 求最",
      "order": 4,
      "draft": false
    },
    {
      "id": "10-05_sequence_dp",
      "title": "10-5. 序列 DP",
      "description": "序列動態規劃：LIS、LCS、編輯距離",
      "tags": [
        "動態規劃",
        "序列 DP",
        "LIS",
        "LCS",
        "編輯距離"
      ],
      "folder": "10",
      "slug": "05_sequence_dp",
      "path": "/articles/10/05_sequence_dp",
      "excerpt": "序列 DP (Sequence DP) 序列 DP 是處理序列(數組、字符串)匹配、比較、查找子序列等問題的重要技術。這類問題通常涉及一個或兩個序列,需要找出它們的某種最優子序列或轉換方式。 核心問題類型 1. 最長遞增子序列 (LIS - Longest Increasing Subsequence) 2. 最長公共子序列 (LCS - Longest Common Subsequence) 3",
      "order": 5,
      "draft": false
    },
    {
      "id": "10-06_grid_matrix_dp",
      "title": "10-6. Grid/Matrix DP",
      "description": "網格動態規劃：路徑問題與矩陣問題",
      "tags": [
        "動態規劃",
        "網格 DP",
        "路徑問題",
        "矩陣"
      ],
      "folder": "10",
      "slug": "06_grid_matrix_dp",
      "path": "/articles/10/06_grid_matrix_dp",
      "excerpt": "Grid/Matrix DP 網格 DP 是處理二維網格或矩陣上路徑、區域問題的重要技術。這類問題通常涉及在網格上移動、計數路徑、或找出滿足特定條件的最優子矩陣。 問題特徵 1. 在二維網格上進行操作 2. 通常只能向右、向下移動 3. 求路徑數量、最優路徑、或最大子矩陣 4. 狀態通常是 `dp[i][j]` 表示到達 (i,j) 的某種最優值 狀態定義 轉移方程模板 --- 問題 1: 不同路",
      "order": 6,
      "draft": false
    },
    {
      "id": "10-07_bitmask_dp",
      "title": "10-7. 狀態壓縮 DP / Bitmask DP",
      "description": "使用位元運算進行狀態壓縮的動態規劃",
      "tags": [
        "動態規劃",
        "狀態壓縮",
        "Bitmask DP",
        "位元運算"
      ],
      "folder": "10",
      "slug": "07_bitmask_dp",
      "path": "/articles/10/07_bitmask_dp",
      "excerpt": "狀態壓縮 DP / Bitmask DP 狀態壓縮 DP 是一種使用位元 (bit) 來表示狀態集合的動態規劃技術。當問題涉及的集合元素數量較小(通常 n ≤ 20)時,可以用一個整數的二進制位來表示集合的狀態,從而大幅簡化狀態表示和轉移。 核心概念 什麼時候使用狀態壓縮? 1. 問題涉及集合或子集 2. 集合大小較小: n ≤ 20 (因為 2²⁰ ≈ 10⁶ 可接受) 3. 需要記錄\"哪些元素",
      "order": 7,
      "draft": false
    },
    {
      "id": "10-08_tree_dp",
      "title": "10-8. Tree DP",
      "description": "樹上的動態規劃問題",
      "tags": [
        "動態規劃",
        "Tree DP",
        "樹",
        "DFS"
      ],
      "folder": "10",
      "slug": "08_tree_dp",
      "path": "/articles/10/08_tree_dp",
      "excerpt": "Tree DP Tree DP 是在樹結構上進行的動態規劃。樹的遞迴結構使得動態規劃非常自然:通過後序遍歷,我們可以先計算子樹的 DP 值,再計算當前節點的 DP 值。 核心概念 樹 DP 的特點 1. 遞迴結構: 樹天然具有遞迴結構 2. 後序遍歷: 先處理子節點,再處理父節點 3. 狀態定義: 通常 `dp[u]` 表示以 u 為根的子樹的最優解 4. 轉移方向: 從子節點向父節點轉移 基本模",
      "order": 8,
      "draft": false
    },
    {
      "id": "10-09_state_machine_dp",
      "title": "10-9. State Machine DP",
      "description": "狀態機動態規劃：股票買賣系列問題",
      "tags": [
        "動態規劃",
        "狀態機 DP",
        "股票問題"
      ],
      "folder": "10",
      "slug": "09_state_machine_dp",
      "path": "/articles/10/09_state_machine_dp",
      "excerpt": "State Machine DP (狀態機 DP) 狀態機 DP 是一種將問題建模為狀態機,然後用動態規劃求解的方法。這類問題的特點是:存在多個狀態,狀態之間可以相互轉換,每次轉換可能有代價或收益。 核心概念 什麼是狀態機? 狀態機是一個包含以下要素的模型: 1. 狀態集合: 系統可能處於的所有狀態 2. 狀態轉移: 從一個狀態到另一個狀態的規則 3. 初始狀態: 起始時的狀態 4. 終止狀態: ",
      "order": 9,
      "draft": false
    },
    {
      "id": "10-10_dp_with_sliding_window",
      "title": "10-10. DP + Sliding Window",
      "description": "結合動態規劃與滑動窗口的優化技巧",
      "tags": [
        "動態規劃",
        "滑動窗口",
        "單調隊列",
        "優化"
      ],
      "folder": "10",
      "slug": "10_dp_with_sliding_window",
      "path": "/articles/10/10_dp_with_sliding_window",
      "excerpt": "DP + Sliding Window DP + 滑動窗口是一種將動態規劃與滑動窗口技巧結合的優化方法。當 DP 的轉移方程涉及一個區間範圍內的最值時,可以使用滑動窗口(通常是單調隊列)來優化時間複雜度。 核心概念 什麼時候需要滑動窗口優化? 當 DP 轉移方程是以下形式時: 樸素做法: 時間複雜度: O(n × k) 使用單調隊列優化後: 時間複雜度: O(n) 單調隊列 單調隊列是一種特殊的雙",
      "order": 10,
      "draft": false
    },
    {
      "id": "10-11_dp_optimization",
      "title": "10-11. DP 優化技巧",
      "description": "動態規劃的進階優化技巧：二分、貪心、決策單調性",
      "tags": [
        "動態規劃",
        "優化",
        "二分搜索",
        "貪心"
      ],
      "folder": "10",
      "slug": "11_dp_optimization",
      "path": "/articles/10/11_dp_optimization",
      "excerpt": "DP 優化技巧 動態規劃的優化是將高時間複雜度的 DP 降低到更可接受的範圍。常見的優化技巧包括:二分搜索、貪心結合、決策單調性等。 優化技巧分類 1. 空間優化: 滾動數組、狀態壓縮 2. 時間優化: 二分搜索、單調隊列、決策單調性 3. 算法結合: DP + 貪心、DP + 二分 --- 技巧 1: 最長遞增子序列的二分優化 (LIS) LeetCode 300. Longest Increa",
      "order": 11,
      "draft": false
    },
    {
      "id": "10-12_digit_dp",
      "title": "10-12. 數位 DP / Digit DP",
      "description": "使用數位動態規劃處理大範圍數字統計問題",
      "tags": [
        "動態規劃",
        "數位 DP",
        "Digit DP",
        "記憶化搜索"
      ],
      "folder": "10",
      "slug": "12_digit_dp",
      "path": "/articles/10/12_digit_dp",
      "excerpt": "數位 DP / Digit DP 數位 DP (Digit Dynamic Programming) 是一種專門用來解決大範圍數字統計問題的動態規劃技術。當數字範圍非常大（如 10^18）但需要統計符合某種「數位性質」的數字個數時，Digit DP 是最有效的方法。 核心概念 什麼時候使用 Digit DP？ 1. 數字範圍非常大：n 可能到 10^18，無法暴力枚舉 2. 統計 [0, n] 或",
      "order": 12,
      "draft": false
    },
    {
      "id": "11-00_introduction",
      "title": "11-0. 進階資料結構概論",
      "description": "理解時間與空間的權衡，選擇合適的資料結構",
      "tags": [
        "Data Structure",
        "Time Complexity",
        "Space Complexity"
      ],
      "folder": "11",
      "slug": "00_introduction",
      "path": "/articles/11/00_introduction",
      "excerpt": "進階資料結構概論 核心思想：Time-Space Trade-off 在演算法設計中，最重要的概念之一就是時間與空間的權衡（Time-Space Trade-off）。我們經常面臨一個選擇： - 犧牲空間換取時間：透過預處理和額外的儲存空間，加速查詢操作 - 犧牲時間換取空間：減少記憶體使用，但可能需要更多的計算時間 經典範例：查詢區間和 假設有一個陣列 `arr = [2, 4, 1, 5, 3",
      "order": 0,
      "draft": false
    },
    {
      "id": "11-01_prefix_sum",
      "title": "11-1. Prefix Sum & Difference Array",
      "description": "前綴和與差分陣列：用空間換時間的經典範例",
      "tags": [
        "Prefix Sum",
        "Difference Array",
        "Array",
        "Preprocessing"
      ],
      "folder": "11",
      "slug": "01_prefix_sum",
      "path": "/articles/11/01_prefix_sum",
      "excerpt": "Prefix Sum & Difference Array 核心概念 Prefix Sum（前綴和）和 Difference Array（差分陣列）是一對互補的技巧： - Prefix Sum：優化區間查詢，將 O(n) 降至 O(1) - Difference Array：優化區間修改，將 O(n) 降至 O(1) 兩者都是用 O(n) 空間 換取 O(1) 時間 的經典範例。 --- 一、Pr",
      "order": 1,
      "draft": false
    },
    {
      "id": "11-02_prefix_sum_2d",
      "title": "11-2. 2D Prefix Sum",
      "description": "二維前綴和：矩陣子區域和的 O(1) 查詢",
      "tags": [
        "2D Prefix Sum",
        "Matrix",
        "Inclusion-Exclusion"
      ],
      "folder": "11",
      "slug": "02_prefix_sum_2d",
      "path": "/articles/11/02_prefix_sum_2d",
      "excerpt": "2D Prefix Sum（二維前綴和） 核心概念 二維前綴和是一維前綴和的擴展，用於快速查詢矩陣中任意子矩形區域的和。 核心思想：預處理 O(m·n)，查詢 O(1) --- 一、原理與公式 定義 對於 `m × n` 矩陣 `matrix`，定義二維前綴和 `prefix[i][j]`： 圖解： 計算公式（預處理） 圖解： 查詢公式（區間和） 查詢子矩陣 `(r1, c1)` 到 `(r2, ",
      "order": 2,
      "draft": false
    },
    {
      "id": "11-03_heap_intro",
      "title": "11-3. Heap (Priority Queue)",
      "description": "堆：動態維護極值的利器",
      "tags": [
        "Heap",
        "Priority Queue",
        "Binary Heap",
        "Top K"
      ],
      "folder": "11",
      "slug": "03_heap_intro",
      "path": "/articles/11/03_heap_intro",
      "excerpt": "Heap (Priority Queue) 核心概念 Heap（堆）是一種完全二叉樹，滿足堆性質： - Max Heap（大頂堆）：父節點 ≥ 子節點 - Min Heap（小頂堆）：父節點 ≤ 子節點 核心優勢：在 O(log n) 時間內動態維護最大值或最小值。 --- 一、Heap 的結構與性質 完全二叉樹 Heap 是一棵完全二叉樹（Complete Binary Tree）： - 除了最",
      "order": 3,
      "draft": false
    },
    {
      "id": "11-04_union_find",
      "title": "11-4. Union Find (Disjoint Set Union)",
      "description": "並查集：高效處理集合合併與連通性問題",
      "tags": [
        "Union Find",
        "DSU",
        "Disjoint Set",
        "Connected Components"
      ],
      "folder": "11",
      "slug": "04_union_find",
      "path": "/articles/11/04_union_find",
      "excerpt": "Union Find (Disjoint Set Union) 核心概念 Union Find（並查集），也稱為 Disjoint Set Union (DSU)，是一種用於維護互斥集合（Disjoint Sets）的資料結構。 核心功能： - `find(x)`：找到元素 x 所在集合的代表元素（根節點） - `union(x, y)`：合併 x 和 y 所在的集合 時間複雜度：經過優化後，兩個",
      "order": 4,
      "draft": false
    },
    {
      "id": "11-05_trie",
      "title": "11-5. Trie (Prefix Tree)",
      "description": "字典樹：高效的字串查詢與前綴匹配",
      "tags": [
        "Trie",
        "Prefix Tree",
        "String",
        "Dictionary"
      ],
      "folder": "11",
      "slug": "05_trie",
      "path": "/articles/11/05_trie",
      "excerpt": "Trie (Prefix Tree) 核心概念 Trie（字典樹/前綴樹）是一種專門用於字串查詢的樹狀資料結構。 核心特性： - 共享公共前綴，節省空間 - 插入、查詢時間：O(L)，L 為字串長度 - 支援前綴匹配，這是 Hash Map 做不到的！ 典型應用： - 字典查詢 - 自動補全 - 拼寫檢查 - IP 路由表 - XOR 最大值（Bitwise Trie） --- 一、Trie 的結",
      "order": 5,
      "draft": false
    },
    {
      "id": "11-06_fenwick_tree_and_segment_tree",
      "title": "11-6. Fenwick Tree & Segment Tree",
      "description": "區間資料結構：從權衡取捨到最佳化方案",
      "tags": [
        "Fenwick Tree",
        "Segment Tree",
        "Binary Indexed Tree",
        "Range Query",
        "Dynamic Programming"
      ],
      "folder": "11",
      "slug": "06_fenwick_tree_and_segment_tree",
      "path": "/articles/11/06_fenwick_tree_and_segment_tree",
      "excerpt": "Fenwick Tree & Segment Tree 前言：Query vs Update 的權衡取捨 問題的本質 對於動態序列，我們需要支援兩種基本操作： - Query（查詢）：取得區間信息（和、最值等） - Update（修改）：修改單點或區間 在實際應用中，這兩種操作的頻率決定了最佳資料結構的選擇。 --- 基礎方案的權衡 場景 1：Immutable Container / Low F",
      "order": 6,
      "draft": false
    },
    {
      "id": "11-07_segment_tree",
      "title": "11-7. Segment Tree Advanced",
      "description": "線段樹進階：Lazy Propagation 與動態開點",
      "tags": [
        "Segment Tree",
        "Lazy Propagation",
        "Range Query",
        "Range Update",
        "Dynamic Segment Tree"
      ],
      "folder": "11",
      "slug": "07_segment_tree",
      "path": "/articles/11/07_segment_tree",
      "excerpt": "Segment Tree Advanced（線段樹進階） 前言 本章節為線段樹的進階內容，主要涵蓋： - Lazy Propagation（懶惰標記）：高效處理區間修改 - 動態開點：處理大範圍稀疏數據 - 複雜應用：多種可結合操作的實現 建議：請先閱讀 11-6. Fenwick Tree & Segment Tree 瞭解基礎概念。 --- 一、Lazy Propagation（懶惰標記） 二",
      "order": 7,
      "draft": false
    },
    {
      "id": "11-08_li_chao_segment_tree",
      "title": "11-8. Li Chao Segment Tree",
      "description": "李超線段樹：動態維護線段集合的利器",
      "tags": [
        "Li Chao Tree",
        "Segment Tree",
        "Convex Hull Trick",
        "Slope Optimization",
        "Dynamic Programming"
      ],
      "folder": "11",
      "slug": "08_li_chao_segment_tree",
      "path": "/articles/11/08_li_chao_segment_tree",
      "excerpt": "Li Chao Segment Tree（李超線段樹） 前言：問題引入 經典問題 給定一個空的線段集合，支援以下操作： 1. 插入線段：添加一條線段 `y = kx + b`（定義域為整個數軸或某個區間） 2. 查詢最大值：查詢在 `x = x₀` 處，所有線段中 `y` 值最大的是多少 範例： --- 暴力做法的瓶頸 問題： - 插入：O(1)  - 查詢：O(n) （n 為線段數量） 如果有 ",
      "order": 8,
      "draft": false
    },
    {
      "id": "12-00_introduction",
      "title": "12-0. 數論介紹",
      "description": "數論的基本概念與在算法競賽中的應用",
      "tags": [
        "Number Theory",
        "Mathematics",
        "Introduction"
      ],
      "folder": "12",
      "slug": "00_introduction",
      "path": "/articles/12/00_introduction",
      "excerpt": "0. 數論介紹 什麼是數論？ 數論（Number Theory）是研究整數性質的數學分支，被譽為「數學的皇后」。在算法競賽與實際應用中，數論提供了強大的數學工具，用於解決各種計算問題。 數論在算法競賽中的重要性 數論在程式設計競賽中扮演關鍵角色，主要原因包括： 1. 密碼學基礎：RSA 加密、數字簽名等現代密碼系統的核心 2. 常見題型：競賽中頻繁出現的質數、GCD/LCM、模運算問題 3. 算法",
      "order": 0,
      "draft": false
    },
    {
      "id": "12-01_modular_arithmetic",
      "title": "12-1. 同餘性質 - Modular Arithmetic",
      "description": "模運算的基本性質、模反元素與大數處理技巧",
      "tags": [
        "Number Theory",
        "Modular Arithmetic",
        "Modular Inverse"
      ],
      "folder": "12",
      "slug": "01_modular_arithmetic",
      "path": "/articles/12/01_modular_arithmetic",
      "excerpt": "1. 同餘性質 - Modular Arithmetic 模運算基礎 定義 對於整數 a 和正整數 m，a mod m 表示 a 除以 m 的餘數。 範例： - `17 mod 5 = 2`（17 = 3 × 5 + 2） - `23 mod 7 = 2`（23 = 3 × 7 + 2） 同餘的定義 若兩個整數 a 和 b 除以 m 的餘數相同，則稱 a 和 b 模 m 同餘，記作： 等價條件： ",
      "order": 1,
      "draft": false
    },
    {
      "id": "12-02_gcd_lcm",
      "title": "12-2. GCD/LCM - 最大公因數與最小公倍數",
      "description": "輾轉相除法、擴展歐幾里得算法與貝祖等式",
      "tags": [
        "Number Theory",
        "GCD",
        "LCM",
        "Euclidean Algorithm"
      ],
      "folder": "12",
      "slug": "02_gcd_lcm",
      "path": "/articles/12/02_gcd_lcm",
      "excerpt": "2. GCD/LCM - 最大公因數與最小公倍數 最大公因數（GCD） 定義 兩個整數 a 和 b 的最大公因數（Greatest Common Divisor）是能同時整除 a 和 b 的最大正整數，記作 `gcd(a, b)`。 範例： - gcd(12, 18) = 6 - gcd(15, 25) = 5 - gcd(7, 13) = 1（互質） 基本性質 1. 交換律：gcd(a, b) ",
      "order": 2,
      "draft": false
    },
    {
      "id": "12-03_prime",
      "title": "12-3. Prime - 質數",
      "description": "質數判定、埃拉托斯特尼篩法、質因數分解與歐拉篩法",
      "tags": [
        "Number Theory",
        "Prime",
        "Sieve",
        "Factorization"
      ],
      "folder": "12",
      "slug": "03_prime",
      "path": "/articles/12/03_prime",
      "excerpt": "3. Prime - 質數 質數的定義與性質 定義 質數（Prime Number）：大於 1 的自然數，只能被 1 和自己整除。 範例：2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, ... 合數（Composite Number）：大於 1 且不是質數的自然數。 基本性質 1. 2 是唯一的偶質數 2. 所有大於 2 的質數都是奇數 3. 1 既不是質數也不是合",
      "order": 3,
      "draft": false
    },
    {
      "id": "12-04_fast_power",
      "title": "12-4. 快速冪 - Modular Exponentiation",
      "description": "快速冪算法、模快速冪與矩陣快速冪的原理與應用",
      "tags": [
        "Number Theory",
        "Fast Power",
        "Binary Exponentiation",
        "Matrix"
      ],
      "folder": "12",
      "slug": "04_fast_power",
      "path": "/articles/12/04_fast_power",
      "excerpt": "4. 快速冪 - Modular Exponentiation 問題引入 基礎問題：計算 a^n（a 的 n 次方） 樸素方法： 時間複雜度：O(n) 問題： - n 很大時（如 10^9），太慢 - 結果容易溢位 解決方案：快速冪算法（Binary Exponentiation） 快速冪原理 分治思想 核心觀察： 範例：計算 3^13 只需 6 次乘法（而非 12 次）！ 二進制表示法 將指數用",
      "order": 4,
      "draft": false
    },
    {
      "id": "12-05_euler_phi",
      "title": "12-5. 歐拉函數 - Euler's Phi Function (*)",
      "description": "歐拉函數的定義、計算與應用（進階主題）",
      "tags": [
        "Number Theory",
        "Euler Phi",
        "Euler's Theorem",
        "Advanced"
      ],
      "folder": "12",
      "slug": "05_euler_phi",
      "path": "/articles/12/05_euler_phi",
      "excerpt": "5. 歐拉函數 - Euler's Phi Function () > 註：本章節為進階主題，重點在概念理解。 歐拉函數的定義 歐拉函數 φ(n)（Euler's Totient Function）表示小於或等於 n 的正整數中，與 n 互質的數的個數。 數學定義： 範例： 基本性質 1. 質數的歐拉函數 若 p 是質數： 證明：1, 2, 3, ..., p-1 都與 p 互質（p 只被 1 和",
      "order": 5,
      "draft": false
    },
    {
      "id": "12-06_extended_euclidean",
      "title": "12-6. 擴展歐幾里得 - Extended Euclidean Algorithm (*)",
      "description": "擴展歐幾里得算法、線性同餘方程與中國餘數定理（進階主題）",
      "tags": [
        "Number Theory",
        "Extended GCD",
        "CRT",
        "Linear Congruence",
        "Advanced"
      ],
      "folder": "12",
      "slug": "06_extended_euclidean",
      "path": "/articles/12/06_extended_euclidean",
      "excerpt": "6. 擴展歐幾里得 - Extended Euclidean Algorithm () > 註：本章節為進階主題，重點在概念理解與基本應用。 擴展歐幾里得算法（Extended GCD） 回顧：貝祖等式 貝祖等式（Bézout's Identity）：對於任意整數 a 和 b，存在整數 x 和 y 使得： 擴展歐幾里得算法就是用來求解這個方程的算法。 算法原理 基礎情況：當 b = 0 時 顯然 ",
      "order": 6,
      "draft": false
    },
    {
      "id": "12-07_advanced_topics",
      "title": "12-7. 進階主題 - Möbius / Segmented Sieve (*)",
      "description": "莫比烏斯函數、分段篩法與米勒-拉賓素性測試（進階主題概覽）",
      "tags": [
        "Number Theory",
        "Möbius",
        "Segmented Sieve",
        "Miller-Rabin",
        "Advanced"
      ],
      "folder": "12",
      "slug": "07_advanced_topics",
      "path": "/articles/12/07_advanced_topics",
      "excerpt": "7. 進階主題 - Möbius / Segmented Sieve () > 註：本章節為進階主題，主要提供概念介紹，不深入實現細節。 莫比烏斯函數（Möbius Function） 定義 莫比烏斯函數 μ(n) 定義如下： 範例： 計算方法 單個數 μ(n)： 時間複雜度：O(√n) 批量計算（線性篩）： 時間複雜度：O(n) 重要性質 1. 莫比烏斯反演公式 若 f(n) = Σ(d|n) ",
      "order": 7,
      "draft": false
    },
    {
      "id": "13-00_introduction",
      "title": "13-0. 貪心法介紹",
      "description": "貪心法的核心思想、可行性條件與證明方法",
      "tags": [
        "greedy",
        "algorithm-design"
      ],
      "folder": "13",
      "slug": "00_introduction",
      "path": "/articles/13/00_introduction",
      "excerpt": "0. 貪心法介紹 什麼是貪心法？ 貪心法 (Greedy Algorithm) 是一種算法設計策略，其核心思想是：在每一步決策中，都選擇當前看起來最優的選擇，從而希望導致全局最優解。 與動態規劃需要考慮所有可能的決策路徑不同，貪心法只關注「當下最好的選擇」，具有以下特點： - 局部最優決策：每一步都做出在當前狀態下最好的選擇 - 不回溯：一旦做出選擇就不再改變 - 無後效性：當前的選擇不依賴於未來",
      "order": 0,
      "draft": false
    },
    {
      "id": "13-01_interval_problems",
      "title": "13-1. 區間問題",
      "description": "貪心法在區間問題中的應用：調度、覆蓋、分組與合併",
      "tags": [
        "greedy",
        "interval",
        "sorting"
      ],
      "folder": "13",
      "slug": "01_interval_problems",
      "path": "/articles/13/01_interval_problems",
      "excerpt": "1. 區間問題 區間問題是貪心法最經典的應用場景之一。這類問題通常涉及時間區間、數字區間或其他形式的區間，需要選擇、合併或分組區間以達到某種最優目標。 核心思想 區間問題的貪心策略通常基於以下排序標準之一： 1. 按結束時間排序：選擇最多不重疊區間 2. 按起始時間排序：合併區間、插入區間 3. 按長度或其他屬性排序：特定問題的特殊需求 問題類型一：區間調度 (Activity Selection",
      "order": 1,
      "draft": false
    },
    {
      "id": "13-02_sequence_greedy",
      "title": "13-2. 序列貪心",
      "description": "序列上的貪心策略：排序、狀態維護與字典序問題",
      "tags": [
        "greedy",
        "array",
        "sorting",
        "monotonic-stack"
      ],
      "folder": "13",
      "slug": "02_sequence_greedy",
      "path": "/articles/13/02_sequence_greedy",
      "excerpt": "2. 序列貪心 序列貪心是指在數組、字符串等序列結構上應用貪心策略。這類問題通常需要： 1. 排序後貪心：先對序列排序，然後按順序做決策 2. 狀態維護：維護一個或多個變量表示當前狀態，貪心地更新 3. 字典序貪心：使用單調棧等結構維護字典序最優 問題類型一：排序 + 貪心 核心思想 通過排序建立處理順序，然後按順序貪心決策。 LeetCode 455: Assign Cookies 問題描述 有",
      "order": 2,
      "draft": false
    },
    {
      "id": "13-03_heap_greedy",
      "title": "13-3. Heap + 貪心",
      "description": "優先隊列在貪心算法中的應用：Huffman編碼、任務調度與掃描線",
      "tags": [
        "greedy",
        "heap",
        "priority-queue",
        "sweep-line"
      ],
      "folder": "13",
      "slug": "03_heap_greedy",
      "path": "/articles/13/03_heap_greedy",
      "excerpt": "3. Heap + 貪心 優先隊列（堆）是貪心算法中最常用的數據結構之一。它能高效地維護「當前最優」的元素，非常適合需要動態選擇最優元素的貪心問題。 核心思想 為什麼使用堆？ - 需要動態地選擇最大/最小元素 - O(log n) 的插入和刪除操作 - O(1) 的查看最值操作 典型場景： 1. Huffman 編碼：每次合併頻率最小的兩個節點 2. 任務調度：每次選擇優先級最高的任務 3. 會議",
      "order": 3,
      "draft": false
    },
    {
      "id": "13-04_astar",
      "title": "13-4. A* 算法",
      "description": "A* 啟發式搜索：貪心與最短路徑的結合",
      "tags": [
        "greedy",
        "shortest-path",
        "heuristic",
        "advanced"
      ],
      "folder": "13",
      "slug": "04_astar",
      "path": "/articles/13/04_astar",
      "excerpt": "4. A 算法 () 註：本章為進階主題，重點在於概念理解和基本應用。A 算法結合了貪心法的局部最優選擇和最短路徑算法的全局最優保證。 什麼是 A 算法？ A (A-Star) 是一種啟發式搜索算法，用於在圖中找到從起點到終點的最短路徑。它是 Dijkstra 算法的改進版本，通過引入啟發函數來加速搜索。 核心思想 評估函數： 貪心策略：每次選擇 f(n) 最小的節點進行擴展。 A vs Dijk",
      "order": 4,
      "draft": false
    },
    {
      "id": "14-00_introduction",
      "title": "14-0. String 介紹",
      "description": "C++ 字串基礎與常用技巧",
      "tags": [
        "string",
        "基礎"
      ],
      "folder": "14",
      "slug": "00_introduction",
      "path": "/articles/14/00_introduction",
      "excerpt": "0. String 介紹 字串（String）是程式設計中最常見的資料結構之一，幾乎所有的程式都會處理文字資料。本章將介紹 C++ 中的字串基礎知識與常用技巧。 C++ 字串基礎 1. `char[]` vs `string` 類別 C++ 提供兩種主要的字串表示方式： C-style 字串（char 陣列） C++ string 類別 選擇建議： - 競賽/演算法題：優先使用 `string`，",
      "order": 0,
      "draft": false
    },
    {
      "id": "14-01_string_manipulation",
      "title": "14-1. String Manipulation",
      "description": "字串基本操作與常見模式",
      "tags": [
        "string",
        "manipulation",
        "two-pointers"
      ],
      "folder": "14",
      "slug": "01_string_manipulation",
      "path": "/articles/14/01_string_manipulation",
      "excerpt": "1. String Manipulation 字串操作是最基礎也是最常見的問題類型。本章將介紹各種基本操作、字元統計、以及字串比較的技巧。 基本操作 1. 反轉字串（Reverse String） 方法 1：雙指針 方法 2：使用標準函數 視覺化過程 2. 大小寫轉換 3. 字串分割（Split） C++ 沒有內建的 split 函數，但可以自己實現： 4. 字串連接（Join） 5. 去除空格（",
      "order": 1,
      "draft": false
    },
    {
      "id": "14-02_palindrome",
      "title": "14-2. 回文 - Palindrome",
      "description": "回文字串的判定與相關問題",
      "tags": [
        "palindrome",
        "two-pointers",
        "dp",
        "expand-around-center"
      ],
      "folder": "14",
      "slug": "02_palindrome",
      "path": "/articles/14/02_palindrome",
      "excerpt": "2. 回文 - Palindrome 回文（Palindrome）是指正讀和反讀都相同的字串，如 \"aba\"、\"racecar\"。回文問題是字串演算法中的經典問題，涉及多種解法技巧。 回文的定義與判定 定義 一個字串 s 是回文，當且僅當： - `s[i] == s[n-1-i]` 對所有 `0 <= i < n/2` 成立 基本判定 忽略非字母數字字元的回文判定 中心擴展法（Expand Aro",
      "order": 2,
      "draft": false
    },
    {
      "id": "14-03_suffix_tree",
      "title": "14-3. Suffix Tree, Suffix Array (*)",
      "description": "後綴樹與後綴陣列的基礎與應用",
      "tags": [
        "suffix-tree",
        "suffix-array",
        "advanced"
      ],
      "folder": "14",
      "slug": "03_suffix_tree",
      "path": "/articles/14/03_suffix_tree",
      "excerpt": "3. Suffix Tree, Suffix Array 後綴樹（Suffix Tree）和後綴陣列（Suffix Array）是處理字串問題的強大工具，適用於子串搜尋、最長公共子串等問題。本章重點介紹概念和實用的後綴陣列。 > 標註 ()： 本章為進階主題，重點在於理解概念和應用，完整實現較為複雜。 後綴（Suffix）的定義 字串 s 的後綴是指從某個位置 i 到結尾的子串。 後綴陣列（Suf",
      "order": 3,
      "draft": false
    },
    {
      "id": "14-04_edit_distance",
      "title": "14-4. Approximate String Matching",
      "description": "編輯距離與近似字串匹配",
      "tags": [
        "edit-distance",
        "dp",
        "levenshtein"
      ],
      "folder": "14",
      "slug": "04_edit_distance",
      "path": "/articles/14/04_edit_distance",
      "excerpt": "4. Approximate String Matching 編輯距離（Edit Distance）是衡量兩個字串相似度的重要指標，廣泛應用於拼寫檢查、DNA 序列比對、模糊搜尋等領域。 編輯距離（Edit Distance / Levenshtein Distance） 定義 編輯距離是將一個字串轉換為另一個字串所需的最少單字元編輯操作次數。 三種操作 1. 插入（Insert）： 插入一個字元",
      "order": 4,
      "draft": false
    },
    {
      "id": "14-05_kmp",
      "title": "14-5. KMP - Knuth-Morris-Pratt",
      "description": "KMP 字串匹配算法詳解",
      "tags": [
        "kmp",
        "string-matching",
        "pattern-matching"
      ],
      "folder": "14",
      "slug": "05_kmp",
      "path": "/articles/14/05_kmp",
      "excerpt": "5. KMP - Knuth-Morris-Pratt KMP 算法是經典的字串匹配算法，由 Knuth、Morris 和 Pratt 於 1977 年提出。它通過預處理模式串，避免重複比較，將時間複雜度從 O(nm) 優化到 O(n+m)。 字串匹配問題 問題定義 給定文本串 text 和模式串 pattern，找到 pattern 在 text 中所有出現的位置。 樸素算法 問題： 當不匹配時",
      "order": 5,
      "draft": false
    },
    {
      "id": "14-06_rabin_karp",
      "title": "14-6. Rabin-Karp (*)",
      "description": "基於滾動雜湊的字串匹配算法",
      "tags": [
        "rabin-karp",
        "rolling-hash",
        "advanced"
      ],
      "folder": "14",
      "slug": "06_rabin_karp",
      "path": "/articles/14/06_rabin_karp",
      "excerpt": "6. Rabin-Karp Rabin-Karp 算法是一種基於雜湊的字串匹配算法,通過 Rolling Hash (滾動雜湊) 技術實現高效匹配。特別適合多模式匹配和重複子串檢測。 > 標註 (): 本章為進階主題,重點介紹概念和實用技巧。 Rabin-Karp 算法原理 核心思想 1. 雜湊比較: 不直接比較字串,而是比較雜湊值 2. 滾動更新: O(1) 時間更新滑動窗口的雜湊值 3. 衝突",
      "order": 6,
      "draft": false
    },
    {
      "id": "14-07_boyer_moore",
      "title": "14-7. Boyer-Moore (*)",
      "description": "Boyer-Moore 字串匹配算法",
      "tags": [
        "boyer-moore",
        "string-matching",
        "advanced"
      ],
      "folder": "14",
      "slug": "07_boyer_moore",
      "path": "/articles/14/07_boyer_moore",
      "excerpt": "7. Boyer-Moore Boyer-Moore 算法是一種高效的字串匹配算法,通過從右向左匹配和智能跳躍,在實務中表現優異,被廣泛應用於文本編輯器和搜尋工具。 > 標註 (): 本章為進階主題,重點介紹概念和核心思想,完整實現較為複雜。 Boyer-Moore 算法原理 核心思想 與 KMP 從左向右不同,Boyer-Moore 從右向左匹配: 兩條規則 1. 壞字元規則 (Bad Char",
      "order": 7,
      "draft": false
    },
    {
      "id": "14-08_z_function",
      "title": "14-8. Z-function (*)",
      "description": "Z-function 與 Z-algorithm",
      "tags": [
        "z-function",
        "z-algorithm",
        "advanced"
      ],
      "folder": "14",
      "slug": "08_z_function",
      "path": "/articles/14/08_z_function",
      "excerpt": "8. Z-function Z-function 是一種強大的字串處理工具,與 KMP 類似但更簡潔。Z-algorithm 可以在 O(n) 時間內計算 Z-function,並用於高效的字串匹配。 > 標註 (): 本章為進階主題,重點介紹核心概念和應用。 Z-function 定義 對於字串 s,Z-function z[i] 定義為: 注意: z[0] 通常定義為 0 或 n (無意義,因",
      "order": 8,
      "draft": false
    },
    {
      "id": "14-09_manacher",
      "title": "14-9. Manacher (*)",
      "description": "Manacher 算法 - O(n) 求最長回文子串",
      "tags": [
        "manacher",
        "palindrome",
        "advanced"
      ],
      "folder": "14",
      "slug": "09_manacher",
      "path": "/articles/14/09_manacher",
      "excerpt": "9. Manacher Manacher 算法是解決最長回文子串問題的最優算法,時間複雜度為 O(n)。它通過巧妙地利用回文的對稱性,避免了中心擴展法的重複計算。 > 標註 (): 本章為進階主題,Manacher 算法思想精妙,適合深入學習。 問題回顧 最長回文子串問題: - 輸入: 字串 s - 輸出: s 中最長的回文子串 之前的方法: - 暴力: O(n³) - 中心擴展: O(n²) -",
      "order": 9,
      "draft": false
    },
    {
      "id": "14-10_string_hashing",
      "title": "14-10. String Hashing",
      "description": "字串雜湊與前綴雜湊陣列",
      "tags": [
        "string-hashing",
        "rolling-hash",
        "prefix-hash"
      ],
      "folder": "14",
      "slug": "10_string_hashing",
      "path": "/articles/14/10_string_hashing",
      "excerpt": "10. String Hashing 字串雜湊是一種將字串映射為整數的技術,允許 O(1) 時間比較子串,廣泛應用於字串匹配、重複檢測等問題。 字串雜湊原理 多項式雜湊 最常用的雜湊函數: 示例 基本實現 前綴雜湊陣列 核心思想 預處理字串的所有前綴雜湊值,實現 O(1) 查詢任意子串雜湊。 構建 子串雜湊計算 雙重雜湊 使用兩個不同的雜湊函數降低碰撞機率。 應用場景 1. 快速子串比較 2. 重",
      "order": 10,
      "draft": false
    },
    {
      "id": "14-11_ac_automation",
      "title": "14-11. AC Automation, Subsequence Automation (*)",
      "description": "AC 自動機與多模式匹配",
      "tags": [
        "ac-automation",
        "aho-corasick",
        "trie",
        "advanced"
      ],
      "folder": "14",
      "slug": "11_ac_automation",
      "path": "/articles/14/11_ac_automation",
      "excerpt": "11. AC Automation, Subsequence Automation AC 自動機 (Aho-Corasick Automaton) 是一種高效的多模式匹配算法,結合了 Trie 和 KMP 的思想,可以同時匹配多個模式串。 > 標註 (): 本章為進階主題,重點介紹概念和應用場景,完整實現較為複雜。 AC 自動機簡介 問題定義 多模式匹配問題: - 輸入: 文本串 text, 模式",
      "order": 11,
      "draft": false
    },
    {
      "id": "14-12_string_compression",
      "title": "14-12. String Compression (*)",
      "description": "字串壓縮算法",
      "tags": [
        "compression",
        "rle",
        "lzw",
        "huffman",
        "advanced"
      ],
      "folder": "14",
      "slug": "12_string_compression",
      "path": "/articles/14/12_string_compression",
      "excerpt": "12. String Compression 字串壓縮是數據壓縮的重要分支,通過減少數據冗餘來節省存儲空間和傳輸帶寬。本章介紹常見的字串壓縮算法。 > 標註 (): 本章為進階主題,重點介紹概念和基本實現,完整的壓縮算法較為複雜。 Run-Length Encoding (RLE) 原理 將連續重複的字元編碼為 (字元, 重複次數)。 基本實現 優化版本 只在重複次數 > 1 時編碼: 適用場景 ",
      "order": 12,
      "draft": false
    },
    {
      "id": "15-01_subsets",
      "title": "15-1. LeetCode 78. Subsets - 九種解法詳解與效能分析",
      "description": "深入探討子集生成問題的九種不同實作方式，包含 DFS、位元運算、BFS、DP 等，並進行效能基準測試",
      "tags": [
        "backtracking",
        "bit-manipulation",
        "dfs",
        "bfs",
        "dynamic-programming",
        "divide-and-conquer"
      ],
      "folder": "15",
      "slug": "01_subsets",
      "path": "/articles/15/01_subsets",
      "excerpt": "15-1. LeetCode 78. Subsets - 九種解法詳解與效能分析 問題描述 給定一個不含重複元素的整數陣列 `nums`，返回該陣列所有可能的子集（冪集）。 注意： 解集不能包含重複的子集。可以按任意順序返回解集。 範例： 對於長度為 n 的陣列，子集總數為 2^n 個（包含空集合）。 --- 核心概念 子集生成問題是組合問題的經典案例，可以從多個角度思考： 1. 選擇視角：對每個",
      "order": 1,
      "draft": false
    }
  ]
}